#!/usr/bin/perl -w
# do not edit manually as it will be overwritten while packaging
our $VERSION = 'API-Change.Feature-Release.Hotfix-Release';

# Copyright (c) TUXEDO Computers GmbH <tux@tuxedocomputers.com>
# This file is part of TUXEDO Tomte.
#
# TUXEDO Tomte is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TUXEDO Tomte is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with TUXEDO Tomte. If not, see <https://www.gnu.org/licenses/>.

use strict qw(vars subs);
use warnings;
use 5.010;

# overrides warnings so that they get logged
local $SIG{__WARN__} = sub {
	my $warning = shift;
	chomp($warning);
	printLog($warning, "L0", '[WARN]');
};

# for file locking
use Fcntl qw(:DEFAULT :flock :seek :Fcompat);
use File::FcntlLock;

use File::Copy;
use File::Find;

# for OLED backlight and edid decrypt
use FindBin qw($Bin);
use lib "$Bin/.";
use Parse::EDID qw(parse_edid);

use Time::HiRes qw(usleep);
use Dpkg::Version;
use JSON;
use Config::Tiny;
use TOML qw(from_toml);

# for Translations
use Locale::TextDomain ('tomte', '/usr/share/locale');
use Locale::TextDomain qw(tomte);
use File::Slurp qw(append_file write_file read_file edit_file);

# for debugging
use Data::Dumper;
# logLevel:
# 0 = normal
# 1 = some debug
# 2 = lots of debug
my $logLevel = 0;

# for console language and locale
my $consoleLanguage = 'LANG=C;LANGUAGE=C;';
$ENV{LC_MESSAGES} = 'C';
$ENV{DEBIAN_FRONTEND} = 'noninteractive';

my $logDir = '/var/log/tomte/';
my $logFile = $logDir.'tomte.log';
my $LOGFILE;
printLog("##############################################################################", 'L0', '[INFO]');

checkAndSetLocale();

###############################################################################
# Argument values given to script
#
my %argValue = (
	command => '',
	module => '',
);

if (@ARGV > 0) { $argValue{command} = $ARGV[0]; }
if (@ARGV > 1) { $argValue{module} = $ARGV[1]; }

# make sure this is the only running instance
use Fcntl ':flock';

my $ME;
open ($ME, '<', $0);
if (!(flock $ME, LOCK_EX|LOCK_NB)) {
	dieSingleton();
}


my $grubFile = '/etc/default/grub';
my $noLogFile = 1;		# 0 = logFile ok, 1 = no logFile
my $noConfigFile = 1;	# 0 = configfile ok, 1 = no configfile
my $configDir = '/etc/tomte/';
my $oldConfigFile = $configDir.'tomte.cfg';
my $configFile = $configDir.'modules.cfg';
my $configIniFile = $configDir.'config.ini';
my $configIniValues = Config::Tiny->new;
readConfigIniValues();
if (defined($configIniValues->{initvalues}->{loglevel})) {
	$logLevel = $configIniValues->{initvalues}->{loglevel};
}
$logLevel = $ENV{LOGLEVEL} // $logLevel;
my $tomteFirstInstallFile = '/tmp/tomteFirstInstall';

my %modeFile = (
	DONT_CONFIGURE => $configDir.'DONT_CONFIGURE',
	UPDATES_ONLY => $configDir.'UPDATES_ONLY',
	AUTOMATIC => $configDir.'AUTOMATIC',
);

my $runningAsRoot = 0;
my $mode = 'AUTOMATIC'; #default mode
my $shareDir = '/usr/share/tuxedo-tomte/';
my $chassisType = 0;
my $distribution;
my $distributionVersionID;
my $distributionVersion;
my $completeDistVersion;
my $ubuntuCodename = "";
my $FAI = 0;
if ($argValue{command} eq 'FAI') {
	$FAI = 1;
}
my $LiveISO = 0;
my $noNetwork = 0;
my $packagekitState = 0;
my $packagekitOriginalState = getSystemdState('packagekit');
my $packagekitOriginalEnabled = getSystemdEnabled('packagekit');
my $triesFile = '/tmp/tomteTries';
my $triesLimit = 12;
my $needsRestartFile = '/tmp/needs_restart';
my $longInstall = 0;
my $restartSystem = 0;
my $startLaterAgain = 0;
my $systemdDelay = 30;
my @availableDebianPackages;
my %packageHash;
my $plasma6Installed = 0;

# get current kernel version
# if in FAI it should check which is the installed
# kernel package version on target
my $kernelRelease;
if ($FAI) {
	my $searchCmd = 'dpkg-query -f \'${db:Status-Abbrev} ${Package} ${Version}\n\' -W \'linux-image-*\'';
	my $dpkgkernel = `$searchCmd`;
	my %kernelHash = $dpkgkernel =~ /ii (.*) (.*)/g;
	my $hashSize = keys %kernelHash;
	if ($hashSize != 0) {
		my $firstkey = (sort(keys %kernelHash))[0];
		$kernelRelease = $kernelHash{$firstkey};
	}
} else {
	$kernelRelease = `uname -r`;
}
$kernelRelease =~ s/[\n\r]//g;
printLog("detected kernel version: $kernelRelease", 'L2', '[DEBUG]');

my $lspciOutput = `lspci -vn 2>/dev/null`;
my $boardnameFilename = "/sys/class/dmi/id/board_name";
my $boardname = '';
$boardname = readFirstLineOfFile($boardnameFilename);

my $boardvendorFilename = "/sys/class/dmi/id/board_vendor";
my $boardvendor = '';;
$boardvendor = readFirstLineOfFile($boardvendorFilename);

my $sysvendorFilename = "/sys/class/dmi/id/sys_vendor";
my $sysvendor = '';
$sysvendor = readFirstLineOfFile($sysvendorFilename);

# for desktop messages
my $sessionID = readFirstLineOfFile('/proc/sys/kernel/random/boot_id');
$sessionID =~ /(.{7})/;
$sessionID = hex($1);
printLog("sessionID: $sessionID", 'TL2', '[DEBUG]');



###############################################################################
# files used by package manager utilities to lock package management
#
my %lockFiles = (
	aptArchivesLock => {
		filename => '/var/cache/apt/archives/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	aptListsLock => {
		filename => '/var/lib/apt/lists/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	dpkgLock => {
		filename => '/var/lib/dpkg/lock',
		FH => '',
		number => '0',
		locked => '0',
	},
	dpkgLockFrontend => {
		filename => '/var/lib/dpkg/lock-frontend',
		FH => '',
		number => '0',
		locked => '0',
	},
);


###############################################################################
# initial definition of post configuration modules
#   command		the command to be executed on the system
#   trigger		'1' / 'undef' wether the command should be executed
#   status		'undef' / 'failed' wether the command execution failed
#
my %postConfProgram = (
	updateGrub => {
		command => 'update-grub',
		trigger => 0,
		status => 'undef',
		description => __('updateGrub_description'),
	},
	updateInitramfs => {
		command => 'update-initramfs -u -k all',
		trigger => 0,
		status => 'undef',
		description => __('updateInitramfs_description'),
	},
);


my %supportedOS = (
	"TUXEDO OS" => ["20.04", "22.04"],
	"TUXEDO_OS Plasma" => ["20.04", "22.04"],
	"KDE neon" => ["20.04", "22.04"],
	"Ubuntu" => ["18.04", "20.04", "22.04"],
	"Linux Mint" => ["21.1", "21.2", "21.3"],
	"elementary OS" => ["6.1", "7.1"]
);

my %tuxedo_repos = (
	"bionic" => {
		"deb" => {
			"content" => ["deb https://deb.tuxedocomputers.com/ubuntu bionic main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-computers.list"
		},
		"graphics" => {
			"content" => ["deb https://graphics.tuxedocomputers.com/ubuntu bionic main"],
			"filename" => "/etc/apt/sources.list.d/graphics-tuxedo.list"
		},
		"oibaf" => {
			"content" => ["deb https://oibaf.tuxedocomputers.com/ubuntu bionic main"],
			"filename" => "/etc/apt/sources.list.d/oibaf-tuxedo.list"
		}
	},

	"focal" => {
		"deb" => {
			"content" => ["deb https://deb.tuxedocomputers.com/ubuntu focal main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-computers.list"},
		"graphics" => {
			"content" => ["deb https://graphics.tuxedocomputers.com/ubuntu focal main"],
			"filename" => "/etc/apt/sources.list.d/graphics-tuxedo.list"},
		"oibaf" => {
			"content" => ["deb https://oibaf.tuxedocomputers.com/ubuntu focal main"],
			"filename" => "/etc/apt/sources.list.d/oibaf-tuxedo.list"
		}
	},

	"jammy" => {
		"deb" => {
			"content" => ["deb https://deb.tuxedocomputers.com/ubuntu jammy main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-computers.list"
		}
	},
	"TUXEDO OS 22.04" => {
		"deb" => {
			"content" => ["deb https://deb.tuxedocomputers.com/ubuntu jammy main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-computers.list"
		},
		"nonplasma6txos" => {
			"content" => ["deb https://txos.tuxedocomputers.com/ubuntu jammy main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-os.list"
		},
		"nonplasma6plasma" => {
			"content" => ["deb https://plasma.tuxedocomputers.com jammy main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-plasma.list"
		},
		"plasma6txos" => {
			"content" => [
				"deb https://txos.tuxedocomputers.com/ubuntu jammy main",
			   	"deb https://txos.tuxedocomputers.com/ubuntu jammy-plasma main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-os.list"
			},
		"plasma6plasma" => {
			"content" => ["deb https://plasma6.tuxedocomputers.com jammy main"],
			"filename" => "/etc/apt/sources.list.d/tuxedo-plasma.list"
		}
	}
);

my %tuxedo_mirrors = (
	"bionic" => {
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu bionic-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic-updates main restricted universe multiverse"
			],
			"filename" => "/etc/apt/sources.list.d/tuxedo-ubuntu-mirrors.list"
		}
	},
	"focal" => {
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse"
			],
			"filename" => "/etc/apt/sources.list.d/tuxedo-ubuntu-mirrors.list"
		}
	},
	"jammy" => {
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse"
			],
			"filename" => "/etc/apt/sources.list.d/tuxedo-ubuntu-mirrors.list"
		}
	},

	"Linux Mint 21.1" => {
		"name" => "vanessa",
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse",
				"deb http://packages.linuxmint.com vanessa main upstream import backport"
			],
			"filename" => "/etc/apt/sources.list.d/official-package-repositories.list"
		}
	},
	"Linux Mint 21.2" => {
		"name" => "victoria",
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse",
				"deb http://packages.linuxmint.com victoria main upstream import backport"
			],
			"filename" => "/etc/apt/sources.list.d/official-package-repositories.list"
		}
	},
	"Linux Mint 21.3" => {
		"name" => "virginia",
		"mirrors" => {
			"content" => [
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu jammy-security main restricted universe multiverse", 
				"deb https://mirrors.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu jammy-updates main restricted universe multiverse",
				"deb http://packages.linuxmint.com virginia main upstream import backport"
			],
			"filename" => "/etc/apt/sources.list.d/official-package-repositories.list"
		}
	}
);

my %flavours = (
	"focal" => {
		"linux-tuxedo-20.04" => "linux-tuxedo-20.04 linux-headers-tuxedo-20.04 linux-image-tuxedo-20.04",
	},

	"jammy" => {
		"linux-tuxedo-22.04" => "linux-tuxedo-22.04 linux-headers-tuxedo-22.04 linux-image-tuxedo-22.04",
	}
);

my %origConfModules = (readTOMLFile('/usr/lib/tomte/config/modules/modules.toml'));

my %tuxedo_devices = (
	'1' => {
		model => ['TUXEDO Aura 15 Gen1'],
		board_name => ['NL5xRU', 'AURA1501'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:a500',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'2' => {
		model => ['TUXEDO Book BA15 Gen1'],
		board_name => ['PF5PU1G'],
		fix => ['nobootonbattery', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'3' => {
		model => ['TUXEDO Book BC15 Gen10', 'TUXEDO Book BC17 Gen10'],
		board_name => ['NHxxRZQ'],
		fix => ['r8168dkms'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:8562',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'4' => {
		model => ['TUXEDO Book BX1507'],
		board_name => ['N350TW'],
		fix => ['tuxedorestoreaudiofix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'5' => {
		model => ['TUXEDO Book DX1508', 'TUXEDO Book DX1708'],
		board_name => ['N8xEJEK'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 12701 Serial Number 585803690',
		usb_device => '',
	},
	'6' => {
		model => ['TUXEDO Book XA15 Gen10'],
		board_name => ['NH5xAx'],
		fix => ['nokeyboardaftersuspendfix', 'corefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:50f0',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'7' => {
		model => ['TUXEDO Book XC15 Gen10', 'TUXEDO Book XC17 Gen10'],
		board_name => ['PB50_70DFx,DDx'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:67e1',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'8' => {
		model => ['TUXEDO Book XP15 Gen12', 'TUXEDO Book XP17 Gen12'],
		board_name => ['PCx0Dx_GN20'],
		fix => ['tuxedodrivers'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['1558:65e5', '1558:67e5'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'9' => {
		model => ['TUXEDO Book XUX7 Gen11'],
		board_name => ['X170SM'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedodrivers'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'10' => {
		model => ['TUXEDO Book XUX7 Gen13'],
		board_name => ['X170KM-G'],
		fix => ['tuxedodrivers', 'nokeyboardaftersuspendfix', 'thunderboltbootdelayfix'],
		flavour => ['20.04', '22.04'],
		pci_id => '1558:7715',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'11' => {
		model => ['TUXEDO EduBook 15 Gen2'],
		board_name => ['EDUBOOK1502'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'12' => {
		model => ['TUXEDO InfinityBook 14 v2'],
		board_name => ['X35R'],
		fix => ['elantechtouchpadfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'13' => {
		model => ['TUXEDO InfinityBook Pro 14 Gen6'],
		board_name => ['PHxTQx1', 'PHxTxX1', 'PH4TQx1'],
		fix => ['lightdmlogindcheckgraphicalfix', 'tuxedotouchpadswitch', 'i915enablepsrfix', 'earlyloadbacklightcontrolfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1d05:1132',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'14' => {
		model => ['TUXEDO InfinityBook Pro 14 v5'],
		board_name => ['N141CU'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'15' => {
		model => ['TUXEDO InfinityBook Pro 15 v5'],
		board_name => ['N150CU'],
		fix => ['nokeyboardaftersuspendfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '1558:1404',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'17' => {
		model => ['TUXEDO Polaris Gen1 AMD NVIDIA GTX1650Ti'],
		board_name => ['POLARIS1501A1650TI', 'POLARIS1701A1650TI'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'amdgpuwithnvidiafix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'18' => {
		model => ['TUXEDO Polaris Gen1 AMD NVIDIA RTX2060'],
		board_name => ['POLARIS1501A2060', 'POLARIS1701A2060'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'amdgpuwithnvidiafix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'19' => {
		model => ['TUXEDO Polaris Gen1 Intel NVIDIA GTX1650Ti'],
		board_name => ['POLARIS1501I1650TI', 'POLARIS1701I1650TI'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'20' => {
		model => ['TUXEDO Polaris Gen1 Intel NVIDIA RTX2060'],
		board_name => ['POLARIS1501I2060', 'POLARIS1701I2060'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'21' => {
		model => ['TUXEDO Pulse 14 Gen1'],
		board_name => ['PULSE1401'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'22' => {
		model => ['TUXEDO Pulse 15 Gen1'],
		board_name => ['PULSE1501'],
		fix => ['amdxhcihcdusbquirksuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'23' => {
		model => ['TUXEDO Stellaris Gen2 AMD', 'TUXEDO Polaris Gen2 AMD'],
		board_name => ['GMxNGxx'],
		fix => ['tuxedotouchpadswitch', 'amdgpubacklightauxoff'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'BOE Model 2423 Serial Number 0',
		usb_device => '',
	},
	'24' => {
		model => ['TUXEDO Stellaris Gen2 Intel', 'TUXEDO Polaris Gen2 Intel'],
		board_name => ['GMxMGxx'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'25' => {
		model => ['TUXEDO Stellaris Gen3 AMD', 'TUXEDO Polaris Gen3 AMD'],
		board_name => ['GMxZGxx'],
		fix => ['tuxedotouchpadswitch', 'tuxedodrivers', 'amdgpubacklightauxoff'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => ['BOE Model 2423 Serial Number 0', 'BOE Model 2420 Serial Number 0'],
		usb_device => '',
	},
	'26' => {
		model => ['TUXEDO Stellaris Gen3 Intel', 'TUXEDO Polaris Gen3 Intel'],
		board_name => ['GMxTGxx'],
		fix => ['tuxedotouchpadswitch', 'tuxedodrivers', 'nvidiabacklightcontrolfix', 'acpibacklightvideofix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'27' => {
		model => ['TUXEDO Trinity Gen1 Intel'],
		board_name => ['TRINITY1501I', 'TRINITY1701I'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'28' => {
		model => ['XMG Fusion 15 L19 GTX1660Ti'],
		board_name => ['LAPQC71A'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'29' => {
		model => ['XMG Fusion 15 L19 RTX2070'],
		board_name => ['LAPQC71B'],
		fix => ['nokeyboardaftersuspendfix', 'tuxedotouchpadswitch'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'30' => {
		model => ['all models'],
		board_name => [''],
		fix => ['apportfix', 'tuxedorepos', 'tuxedomirrors'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'32' => {
		model => ['all with fingerprintreader'],
		board_name => [''],
		fix => ['fingerprintreader'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['147e:100[0123]', '147e:20(15|16|20)', '147e:300[01]', '147e:500[23]', '0483:201[56]', '1c7a:0603'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'33' => {
		model => ['all with LTE module ME936'],
		board_name => [''],
		fix => ['huaweime936fix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '12d1:15bb',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => 'ME936',
	},
	'34' => {
		model => ['all with NVIDIA'],
		board_name => [''],
		fix => ['nvidiadriver'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '030[02]:',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'35' => {
		model => ['all with OLED display'],
		board_name => [''],
		fix => ['tuxedooledbrt'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'SDC Model 41001 Serial Number 0',
		usb_device => '',
	},
	'36' => {
		model => ['Kingston NVMe'],
		board_name => [''],
		fix => ['tuxedonvmefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '2646:2263',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'37' => {
		model => ['InfinityBook S 17 Gen6', 'InfinityBook S 15 Gen6'],
		board_name => ['NS50_70MU', 'NS50MU'],
		fix => ['i8042noauxfix'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'38' => {
		model => ['TUXEDO Book XP14 Gen12'],
		board_name => ['NV4XMB,ME,MZ'],
		fix => ['lightdmlogindcheckgraphicalfix', 'earlyloadbacklightcontrolfix'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'39' => {
		model => ['TUXEDO Aura 15 Gen2'],
		board_name => ['NL5xNU'],
		fix => [],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'40' => {
		model => ['all models'],
		board_name => [''],
		fix => ['apportfix', 'tuxedorepos', 'tuxedomirrors'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'41' => {
		model => ['TUXEDO Stellaris Gen4 Intel'],
		board_name => ['GMxAGxx'],
		fix => ['tuxedodrivers', "tuxedotouchpadswitch"],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'42' => {
		model => ['all with LTE module ME906s'],
		board_name => [''],
		fix => ['huaweime906sfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '12d1:15c1',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => 'ME906',
	},
	'43' => {
		model => ['all with cardreader Realtek RTS522A'],
		board_name => [''],
		fix => ['cardreaderfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => ['10ec:522a'],
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'44' => {
		model => ['all with Realtek RTL8125'],
		board_name => [''],
		fix => ['tuxedor8125dkms'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '10ec:8125',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'45' => {
		model => ['TUXEDO Pulse 15 Gen2'],
		board_name => ['PF5LUXG'],
		fix => ['tuxedotouchpadswitch', 'samsungnvmefix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => 'linux-tuxedo-22.04-edge',
		display => '',
		usb_device => '',
	},
	'46' => {
		model => ['TUXEDO InsanityBook 15 v1'],
		board_name => ['P95_HP', 'P95_HR', 'P95_HP,HR,HQ'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 21229 Serial Number 808797180',
		usb_device => '',
	},
	'47' => {
		model => ['XP1507'],
		board_name => ['P95_HP', 'P95_HR', 'P95_HP,HR,HQ'],
		fix => ['backlightfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => 'AUO Model 21229 Serial Number 808797180',
		usb_device => '',
	},
	'48' => {
		model => ['TUXEDO Stellaris Gen4 AMD'],
		board_name => ['GMxRGxx'],
		fix => ['tuxedodrivers', "tuxedotouchpadswitch"],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'49' => {
		model => ['TUXEDO InfinityBook Pro 16 Gen7'],
		board_name => ['PHxARX1_PHxAQF1', 'PH6AG01_PH6AQ71_PH6AQI1'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => 'linux-tuxedo-22.04-edge',
		display => '',
		usb_device => '',
	},
	'50' => {
		model => ['TUXEDO Gemini 17 Gen1'],
		board_name => ['PD5x_7xPNP_PNR_PNN_PNT'],
		fix => ['tuxedodrivers', 'acpibacklightvideofix'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => 'linux-tuxedo-22.04-next',
		display => '',
		usb_device => '',
	},
	'51' => {
		model => ['TUXEDO Stellaris 16 Gen5 Intel'],
		board_name => ['GMxPXxx'],
		fix => ['tuxedodrivers', 'tuxedotouchpadswitch'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'52' => {
		model => ['all with Intel Gen13 PCI USB controller'],
		board_name => [''],
		fix => ['intelgenXIIIpowerctlfix'],
		flavour => ['22.04'],
		pci_id => '8086:1135',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'53' => {
		model => ['all with plasma-workspace >=5.25'],
		board_name => [''],
		fix => [''],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'54' => {
		model => ['TUXEDO InfinityBook Pro 14/16 Gen8'],
		board_name => ['PH4PRX1_PH6PRX1', 'PH4PG31', 'PH6PG01_PH6PG71'],
		fix => ['tuxedotouchpadswitch', 'disablegucfix'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'55' => {
		model => ['desktoppc'],
		board_name => [''],
		fix => ['apportfix', 'kerneltuxedo2204', 'tuxedocontrolcenter', 'tuxedokeyboard', 'tuxedomirrors', 'tuxedorepos', 'tuxedotouchpadswitch'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'56' => {
		model => ['TUXEDO InfinityBook Pro 14 Gen7'],
		board_name => ['PHxARX1_PHxAQF1'],
		fix => ['tuxedotouchpadswitch'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => 'linux-tuxedo-22.04-edge',
		display => '',
		usb_device => '',
	},
	'57' => {
		model => ['TUXEDO Gemini 15 Gen1'],
		board_name => ['PD5x_7xPNP_PNR_PNN_PNT'],
		fix => ['tuxedodrivers', 'acpibacklightvideofix'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => 'linux-tuxedo-22.04-next',
		display => '',
		usb_device => '',
	},
	'58' => {
		model => ['TUXEDO Aura 14 Gen3'],
		board_name => ['NL45PU2'],
		fix => ['r8168dkms'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'59' => {
		model => ['TUXEDO Aura 15 Gen3'],
		board_name => ['NL57PU'],
		fix => ['r8168dkms'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'60' => {
		model => ['TUXEDO Stellaris 16 Gen5 AMD'],
		board_name => ['GM6XGxX'],
		fix => ['tuxedodrivers', 'tuxedotouchpadswitch'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'61' => {
		model => ['all notebooks'],
		board_name => [''],
		fix => ['tuxedokeyboard'],
		flavour => ['18.04', '20.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'62' => {
		model => ['all notebooks'],
		board_name => [''],
		fix => ['tuxedodrivers'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'63' => {
		model => ['all notebooks from TongFang'],
		board_name => [''],
		fix => ['tuxedotouchpadswitch'],
		flavour => [''],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'64' => {
		model => ['all notebooks'],
		board_name => [''],
		fix => [''],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'65' => {
		model => ['all Elementary OS'],
		board_name => [''],
		fix => ['elementaryosdkmspinningfix'],
		flavour => ['6.1', '7.2'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'66' => {
		model => ['all with LTE module ME906s HP rebranded'],
		board_name => [''],
		fix => ['huaweime906shpfix'],
		flavour => ['18.04', '20.04', '22.04'],
		pci_id => '03f0:a31d',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => 'ME906',
	},
	'67' => {
		model => ['Sirius 16 - Gen1'],
		board_name => ['APX958'],
		fix => ['amdgpudisablepsr'],
		flavour => ['22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'68' => {
		model => ['TUXEDO InfinityBook S 15/17 - Gen8'],
		board_name => ['NS5X_NS7XAU', 'NS5X_7XAU'], # case insensitive
		fix => ['nvmequirkswitchtodeepsleepfix'],
		flavour => ['22.04'],
		pci_id => '144d:a80d',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'69' => {
		model => ['all'],
		board_name => [''],
		fix => ['tuxedoplasmaupgrade'],
		flavour => ['TUXEDO OS 2 22.04'],
		pci_id => '',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	},
	'70' => {
		model => ['all with ethernet controller YT6801'],
		board_name => [''],
		fix => ['tuxedoyt6801'],
		flavour => ['22.04', 'TUXEDO OS'],
		pci_id => '1f0a:6801',
		cpu => '',
		kernel => '',
		display => '',
		usb_device => '',
	}


);

foreach my $module (keys %origConfModules) {
	$origConfModules{$module}{'description'} = __($module . "_description");
}


###############################################################################
# simple print out of all supported devices and fixes
#
sub printTuxedoDevices {
	my $ID;
	foreach $ID (keys %tuxedo_devices) {
		if ((defined $tuxedo_devices{$ID}) && ($tuxedo_devices{$ID} ne '') && (exists $tuxedo_devices{$ID})) {
			printIfExistsNotUndefinedNotEmpty("$ID", "model");
			printIfExistsNotUndefinedNotEmpty("$ID", "board_name");
			printIfExistsNotUndefinedNotEmpty("$ID", "fix");
			printIfExistsNotUndefinedNotEmpty("$ID", "flavour");
			printIfExistsNotUndefinedNotEmpty("$ID", "pci_id");
			printIfExistsNotUndefinedNotEmpty("$ID", "cpu");
			printIfExistsNotUndefinedNotEmpty("$ID", "kernel");
			printIfExistsNotUndefinedNotEmpty("$ID", "display");
			printIfExistsNotUndefinedNotEmpty("$ID", "usb_device");
		}
	}
}



sub printIfExistsNotUndefinedNotEmpty {
	my $ID = shift;
	my $type = shift;
	if ((defined $tuxedo_devices{$ID}{$type}) && ($tuxedo_devices{$ID}{$type} ne '') && (exists $tuxedo_devices{$ID}{$type})) {
		if (ref($tuxedo_devices{$ID}{$type}) eq 'ARRAY') {
			if ($tuxedo_devices{$ID}{$type}->[0] ne '') {
				my $joinedArray = join ' ', @{$tuxedo_devices{$ID}{$type}};
				print "$type: $joinedArray\n";
			}
		} else {
			print "$type: $tuxedo_devices{$ID}{$type}\n";
		}
	}
}



# hash to load the configfile
# is a copy from origConfModules to exclude undefined values
my %localConfModules = %origConfModules;


# empty hash, will be filled with successfully installed modules
# as hashes: {modulename}{status}
# where status should be "success" or "failed"
#
my %configuredModules;


###############################################################################
# die if another instance is running
#
sub dieSingleton {
	print "Another instance is already running, please wait till it is finished\n";
	exit (1);
}


sub checkAndSetLocale {
    my $default_locale = "en";

    # Check if either LANG or LANGUAGE is set
    if (defined $ENV{'LANG'} || defined $ENV{'LANGUAGE'}) {
		# allow manual override of LANGUAGE environment variable
        my $lang = $ENV{'LANGUAGE'} || $ENV{'LANG'} || $default_locale;

        # Split the language code from the full locale using dot as the delimiter
        # a $lang could be de, de_DE or de_DE.UTF8
        my $language_code = (split /\./, $lang)[0] // $lang;

		# $language_code is now de or de_DE
        if ($language_code) {
			my ($found_folder, $locale_path) = getMatchingLocaleForLang($language_code);

            # Check if the directory exists
            if ($found_folder ne 0) {
				$ENV{'LANG'} = $ENV{'LANGUAGE'} = $found_folder;

                printLog("Found Tomte locale file in: $locale_path", "L1", '[INFO]');
            } else {
				if(length $language_code eq 2){
					# already searched possible endings and didn't found
					printLog("Tomte locale file doesn't exist for requested language $lang. Setting to default: $default_locale", "L1", '[INFO]');
					$ENV{'LANG'} = $ENV{'LANGUAGE'} = $default_locale;
				} else {
					# reduce de_DE to de to search broader
					$language_code = (split /_/, $language_code)[0];
					my ($found_folder, $locale_path) = getMatchingLocaleForLang($language_code);

					# Check if the directory exists
					if ($found_folder ne 0) {
						if($language_code ne $found_folder){
							$ENV{'LANG'} = $ENV{'LANGUAGE'} = $found_folder;
						}

						printLog("Found Tomte locale file in: $locale_path", "L1", '[INFO]');
					} else {
						printLog("Tomte locale file doesn't exist for requested language $lang. Setting to default: $default_locale", "L1", '[INFO]');
						$ENV{'LANG'} = $ENV{'LANGUAGE'} = $default_locale;
					}
				}
            }
        } else {
            printLog("Invalid LANG or LANGUAGE format: '$lang'", "L1", '[WARN]');
            printLog("Setting both to default: $default_locale", "L1", '[INFO]');
            $ENV{'LANG'} = $ENV{'LANGUAGE'} = $default_locale;
        }
    } else {
        # Neither LANG nor LANGUAGE is set. Setting both to default
        printLog("Neither LANG nor LANGUAGE is set. Setting both to default: $default_locale", "L1", '[WARN]');
        $ENV{'LANG'} = $ENV{'LANGUAGE'} = $default_locale;
    }
}

sub getMatchingLocaleForLang {
	my $lang = shift;
	printLog("Trying matching language for: $lang", "L1", '[INFO]');
	# Directory where the existing translations can be found
	my $locale_base_path = "/usr/share/locale";

	my $found_language = 0;
	my $locale_path = 0;

	my @files = glob($locale_base_path . "/" . $lang . "*/LC_MESSAGES/tomte.mo");

	foreach my $path (@files) {
		$path =~ s/\/LC_MESSAGES\/tomte.mo//i;
		$found_language = $path =~ s/$locale_base_path\///ir;
		printLog("Found valid Tomte locale file in $locale_base_path/$found_language", "L1", '[INFO]');
		last;
	}
	unless ($found_language) {
		printLog("Found no valid Tomte locale file in $locale_base_path/$lang", "L1", '[ERROR]');
	}

	return ($found_language, "$locale_base_path/$found_language");
}


###############################################################################
# checks if a given file is locked
# returns 0 if it is not locked
# returns 1 if it is locked
# returns -1 if something went wrong
#
sub isLocked {
	my $key = shift;
	my $filename = $lockFiles{$key}{filename};
	my $FH;
	my $fs;
	my $num;
	unless (-e $filename) {
		printLog("Locking: $filename does not exist", 'L2', '[ERROR]');
		return (0);
	}
	if (sysopen($FH, $filename, O_RDWR | O_CREAT)) {
		$FH->autoflush(1);
		printLog("Locking: checking lock: $filename", 'L2', '[DEBUG]');
		$fs = new File::FcntlLock;
		$fs->l_type( F_WRLCK );
		$fs->l_whence( SEEK_SET );
		$fs->l_start( 0 );
		if ($fs->lock( $FH, F_GETLK )) {
			unless ($fs->l_type() == F_UNLCK) {
				printLog("Locking: => is locked", 'L2', '[DEBUG]');
				return (1);
			} else {
				printLog("Locking: => is not locked", 'L2', '[DEBUG]');
				return (0);
			}
		} else {
			printLog("Locking: failed to get lock information on: $filename error: $fs->error", 'L0', '[ERROR]');
			return (-1);
		}
	} else {
		printLog("Locking: failed to open: $filename", 'L0', '[ERROR]');
		return (-1);
	}
}



###############################################################################
# checks if all required files for package management are unlocked
# only use if it is not required to lock the files simultaneus or race
# conditions will rise!!
# returns 1 if any of the required files is locked
# returns 0 if all of the required files are unlocked
# returns -1 if something went wrong
#
sub isPMlocked {
	my $key;
	my $result;
	foreach $key (keys %lockFiles) {
		$result = isLocked($key);
		if ($result == 1) {
			printLog("Locking: one or more files are locked", 'L2', '[DEBUG]');
			return (1);
		}
		if ($result == -1) {
			printLog("Locking: something went wrong while checking for file locks", 'L2', '[WARN]');
			return (-1);
		}
	}
	printLog("Locking: all files are unlocked", 'L2', '[DEBUG]');
	return (0);
}



###############################################################################
# locks a file acquireLock(filename) if the file was not locked by another
# process already
# returns 1 if file could be locked
# returns 0 if file could not be locked
#
sub acquireLock {
	my $key = shift;
	my $filename = $lockFiles{$key}{filename};
	my $FH;
	my $fs;
	my $num;
	if (sysopen($FH, $filename, O_RDWR | O_CREAT)) {
		$FH->autoflush(1);
		printLog("Locking: acquiring lock: $filename", 'L2', '[DEBUG]');
		$fs = new File::FcntlLock;
		$fs->l_type( F_WRLCK );
		$fs->l_whence( SEEK_SET );
		$fs->l_start( 0 );
		if ($fs->lock( $FH, F_SETLK )) {
			printLog("Locking: locking successfull", 'L2', '[DEBUG]');
			$num = <$FH> || 0;
			$lockFiles{$key}{'FH'} = $FH;
			$lockFiles{$key}{'number'} = $num;
			$lockFiles{$key}{'locked'} = 1;
			return (1);
		} else {
			$lockFiles{$key}{'locked'} = 0;
			printLog("Locking: failed to get write lock: $filename: $fs->error", 'L0', '[WARN]');
			return (0);
		}
	} else {
		printLog("Locking: failed to open: $filename: $!", 'L2', '[ERROR]');
		return (0);
	}
}



###############################################################################
# releases the lock on ONE file
# releaseLock(filename)
# returns 1 if lock could be released
# returns 0 if something went wrong
#
sub releaseLock {
	my $key = shift;
	my $filename = $lockFiles{$key}{filename};
	my $FH = $lockFiles{$key}{FH};
	my $num = $lockFiles{$key}{number};
	my $fs;
	if (seek($FH, 0, SEEK_SET)) {
		if (print $FH "$num\n") {
			if (truncate($FH, tell($FH))) {
				$fs = new File::FcntlLock;
				$fs->l_type(F_UNLCK);
				if ($fs->lock( $FH, F_SETLK )) {
					if (close($FH)) {
						$lockFiles{$key}{'locked'} = 0;
						printLog("Locking: lock released on $filename", 'L2', '[DEBUG]');
						return (1);
					} else {
						printLog("Locking: close failed!: $filename: $!", 'L2', '[ERROR]');
						return (0);
					}
				} else {
					printLog("Locking: unlock failed!: $filename: $fs->error", 'L2', '[ERROR]');
					return (0);
				}
			} else {
				printLog("Locking: truncate failed!: $filename: $!", 'L2', '[ERROR]');
				return (0);
			}
		} else {
			printLog("Locking: write failed!: $filename: $!", 'L2', '[ERROR]');
			return (0);
		}
	} else {
		printLog("Locking: seek failed!: $filename: $!", 'L2', '[ERROR]');
		return (0);
	}
}



###############################################################################
# locks all packagemanagement files
# it unlocks all files if some were locked by another process
# returns 1 if all files could be locked
# returns 0 if some could not be locked
#
sub lockPM {
	my $key;
	my $lockFilesHashSize = keys %lockFiles;
	my $processedLockFiles = 0;

	# in FAI it should never be necessary to lock any files
	if ($FAI) {
		return (1);
	}
	printLog("Locking: trying to lock all files for Tomte", 'L2', '[DEBUG]');
	foreach $key (keys %lockFiles) {
		# stop if can't get lock
		last if (acquireLock($key) != 1);
		$processedLockFiles++;
	}
	if ($processedLockFiles < $lockFilesHashSize) {
		printLog("Locking: !!! some files are already locked! reverting all locks", 'L2', '[DEBUG]');
		unlockPM('Locking: some files locked -> reverting');
		return (0);
	}
	printLog("Locking: ### all files locked for Tomte", 'L3', '[DEBUG]');
	return (1);
}



###############################################################################
# unlocks all files from package management
# only unlocks locks owned by itself!!
# a reason for unlocking should be given as string, for logging purposes
# unlockPM('reason')
# returns 1 if unlocked
# returns 0 if some could not be unlocked
#
sub unlockPM {
	my $reason = shift;
	my $key;
	my $hashSize = keys %lockFiles;
	my $countReleased = 0;
	my $countToRelease = 0;
	printLog("Locking: attempting to unlock all files for >$reason< ...", 'L2', '[DEBUG]');
	foreach $key (keys %lockFiles) {
		printLog("Locking: is $key locked?: $lockFiles{$key}{locked}", 'L2', '[DEBUG]');
		if ($lockFiles{$key}{locked}) {
			printLog("Locking: try to unlock", 'L2', '[DEBUG]');
			$countToRelease++;
			$countReleased += releaseLock($key);
			printLog("Locking: released $countReleased from $countToRelease", 'L2', '[DEBUG]');
		}
	}
	if ($countReleased == $countToRelease) {
		printLog("Locking: OOO successfully released all locks for >$reason<", 'L2', '[DEBUG]');
		return (1);
	} else {
		printLog("Locking: XXX unlock failed: $countReleased locks released out of $countToRelease for >$reason<", 'L2', '[ERROR]');
	}
	return (0);
}



###############################################################################
# reads a file and returns a line
# chomps the line
# returns undef if file can't be opened
#
sub readFirstLineOfFile {
	my @lines = read_file(shift, {chomp => 1, 'err_mode' => 'carp'});
	return $lines[0];
}





###############################################################################
# counts the lines in a given string
#
sub countLinesInString {
	my $myString = shift;
	return 0 if( !defined $myString or $myString eq "");
	my $lastchar = substr $myString, -1,1;
	my $numlines = () = $myString =~ /\n/g;
	# was last line a whole line with a "\n"?;
	return $numlines + ($lastchar ne "\n");
}




###############################################################################
# find OS name and version and put them into $distribution and
# $distributionVersionID
# e.g.:
# $distribution = 'Ubuntu'
# $distributionVersionID = '22.04'
# $completeDistVersion = 'Ubuntu 22.04'
#
sub readOSData {
	my $osReleaseFile = '/etc/os-release';
	my @osReleaseLines;

	@osReleaseLines = read_file($osReleaseFile, 'err_mode' => 'carp');

	if ( !@osReleaseLines ) {
		print "Can't determine the operating system\n";
		exit (0);
	}
	foreach ( @osReleaseLines ) {
		if ( $_ =~ /^NAME=/ ) {
			# e.g. Ubuntu
			$_ =~ /NAME=\"(.*)\"/;
			$distribution = $1;
		}
		if ( $_ =~ /^VERSION_ID=/ ) {
			# e.g. 22.04
			$_ =~ /VERSION_ID=\"(.*)\"/;
			$distributionVersionID = $1;
		}
		if ( $_ =~ /^UBUNTU_CODENAME=/ ) {
			# e.g. jammy
			$_ =~ /UBUNTU_CODENAME=(.*)/;
			$ubuntuCodename = $1;
		}
		if ( $_ =~ /^VERSION=/ ) {
			# e.g. 22.04.4 LTS (Jammy Jellyfish)
			$_ =~ /VERSION=\"(.*)\"/;
			$distributionVersion = $1;
		}
	}
	$completeDistVersion = $distribution.' '.$distributionVersionID;
}



###############################################################################
# checks the list of supported distributions and versions and returns
# 1 if supported
# 0 if not
#
sub isOSSupported {
	if (grep { $_ eq $distributionVersionID } @{$supportedOS{$distribution}}) {
		return (1);
	} elsif (exists($supportedOS{$distribution})) {
		printLog("The version $distributionVersionID of $distribution is not supported.", 'TL0', '[FATAL]');
		messageDesktop(__("This OS version is not supported"),
						__x("The version {version} of {distribution} is not supported.",
								("version" => $distributionVersionID, "distribution" => $distribution)),
								2, 'dialog-warning');
		return (0);
	}
	printLog("This OS is not supported", 'TL0', '[FATAL]');
	printLog("distribution: >$distribution<", 'TL1', '[INFO]');
	printLog("version: >$distributionVersionID<", 'TL1', '[INFO]');
	return (0);
}


###############################################################################
# check basic requirements the system should fullfill and
# install missing parts
#
sub prerequisites {
	my $module;
	printLog("starting prerequisites", 'L1', '[INFO]');
	foreach $module (sort keys %origConfModules) {
		# basically the required repos
		if (($origConfModules{$module}{order} eq 'first') &&
			($origConfModules{$module}{blocked} eq 'no')) {
			reconfigureSingleModule($origConfModules{$module}{name});
		}
	}
	# wait max. 10 sec. as it takes some time to get network
	checkNetwork(10,1);
	my $command = $consoleLanguage.'apt-get update 2>/dev/null';
	my $output = `$command`;
	printLog("return from apt-get update: $output", 'L2', '[DEBUG]');
	printLog("ending prerequisites", 'L1', '[INFO]');
}



###############################################################################
# check whether the module is required for the system
# checks only for hardware
#
sub checkRequirements {
	my $FH;
	my $biosVersion;
	my $lsusb;

	# check values for each module
	if (($boardname =~ /NS50_70MU/) ||
		($boardname =~ /NS50MU/)) {
		if ($FAI) {
			if ($ENV{classes} =~ /^((UBUNTU_1804_LTS)|(UBUNTU_1804))/gm) {
				$origConfModules{nokeyboardaftersuspendfix}{required} = 'yes';
				printLog("detected $origConfModules{nokeyboardaftersuspendfix}{name} issue", 'L1', '[INFO]');
			}
		} else {
			my $minKernelVersionFornoauxfix = '5.15.0-53';
			if (version_compare($kernelRelease, $minKernelVersionFornoauxfix) == -1) {
				$origConfModules{i8042noauxfix}{required} = 'yes';
				printLog("detected $origConfModules{i8042noauxfix}{name} issue", 'L1', '[INFO]');
			}
		}
	}

	if ($boardname =~ /PF5PU1G/) {
		$origConfModules{nobootonbattery}{required} = 'yes';
		printLog("detected $origConfModules{nobootonbattery}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /NL5xRU/) ||
		($boardname =~ /EDUBOOK1502/) ||
  		($boardname =~ /AURA1501/)) {
		$origConfModules{amdxhcihcdusbquirksuspendfix}{required} = 'yes';
		printLog("detected $origConfModules{amdxhcihcdusbquirksuspendfix}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ /APX958/)) {
		$origConfModules{amdgpudisablepsr}{required} = 'yes';
		printLog("detected $origConfModules{amdgpudisablepsr}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/)) {
		if ($distributionVersionID =~ /18.04/) {
			$origConfModules{amdgpuwithnvidiafix}{required} = 'yes';
			printLog("detected $origConfModules{amdgpuwithnvidiafix}{name} issue", 'L1', '[INFO]');
		}
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /PB50_70DFx,DDx/) ||
   		($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /N141CU/) ||
		($boardname =~ /N150CU/) ||
   		($boardname =~ /NH5xAx/) ||
   		($boardname =~ /NL5xRU/) ||
		($boardname =~ /AURA1501/) ||
		($boardname =~ /EDUBOOK1502/) ||
		($boardname =~ /NS50MU/) ||
		($boardname =~ /NS50_70MU/) ||
		($boardname =~ /NJ50_70CU/) ||
		($boardname =~ /X170KM-G/ )) {
		if ($FAI) {
			if ($ENV{classes} =~ /^((UBUNTU_1804_LTS)|(UBUNTU_1804))/gm) {
				$origConfModules{nokeyboardaftersuspendfix}{required} = 'yes';
				printLog("detected $origConfModules{nokeyboardaftersuspendfix}{name} issue", 'L1', '[INFO]');
			}
		} else {
			my $minKernelVersionFornoauxfix = '5.15.0-53';
			if (version_compare($kernelRelease, $minKernelVersionFornoauxfix) == -1) {
				$origConfModules{nokeyboardaftersuspendfix}{required} = 'yes';
				printLog("detected $origConfModules{nokeyboardaftersuspendfix}{name} issue", 'L1', '[INFO]');
			}
		}
	}

	if ($boardname =~ /X35R/) {
		$origConfModules{elantechtouchpadfix}{required} = 'yes';
		printLog("detected $origConfModules{elantechtouchpadfix}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /PF5PU1G/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1501I1650TI/) ||
		($boardname =~ /POLARIS1501I2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1701I1650TI/) ||
		($boardname =~ /POLARIS1701I2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /TRINITY1501I/) ||
		($boardname =~ /TRINITY1701I/) ||
		($boardname =~ /PHxTxX1/) ||
		($boardname =~ /PH4TQx1/) ||
		($boardname =~ /PHxTQx1/) || #alias to PH4TQx1
		($boardname =~ /GMxNGxx/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxTGxx/) ||
		($boardname =~ /GMxAGxx/) ||
		($boardname =~ /GMxMGxx/) ||
		($boardname =~ /GMxRGxx/) ||
		($boardname =~ /PF5LUXG/) ||
		($boardname =~ /PHxARX1_PHxAQF1/) ||
		($boardname =~ /PH6AG01_PH6AQ71_PH6AQI1/) ||
		($boardname =~ /GMxPXxx/) ||
		($boardname =~ /PH4PRX1_PH6PRX1/) ||
		($boardname =~ /PH4PG31/) ||
		($boardname =~ /PH6PG01_PH6PG71/) ||
		($boardname =~ /GM6XGxX/)) {
		$origConfModules{tuxedotouchpadswitch}{required} = 'yes';
		printLog("detected $origConfModules{tuxedotouchpadswitch}{name} issue", 'L1', '[INFO]');
	}

	if ($boardvendor =~ /NB02/) {
		$origConfModules{tuxedotouchpadswitch}{required} = 'yes';
		printLog("detected $origConfModules{tuxedotouchpadswitch}{name} issue", 'L1', '[INFO]');
	}

	if ($boardname =~ /N8xEJEK/) {
		if (isDisplayPresent("AUO Model 12701 Serial Number 585803690")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog("detected $origConfModules{backlightfix}{name} issue", 'L1', '[INFO]');
		}
	}

	if ($boardname =~ /P95_HP/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog("detected $origConfModules{backlightfix}{name} issue", 'L1', '[INFO]');
		}
	}

	if ($boardname =~ /P95_HR/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog("detected $origConfModules{backlightfix}{name} issue", 'L1', '[INFO]');
		}
	}

	if ($boardname =~ /P95_HP,HR,HQ/) {
		if (isDisplayPresent("AUO Model 21229 Serial Number 808797180")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog("detected $origConfModules{backlightfix}{name} issue", 'L1', '[INFO]');
		}
	}

	# get the BIOS version
	# deactivated but could be useful if version changes in the future
	# $main::biosVersion = `dmidecode -s bios-version`;
	$main::biosVersion = '1.07.04NBC';
	$main::biosVersion =~ s/\s//g;
	if ($boardname =~ /NH5xAx/) {
		$origConfModules{corefix}{required} = 'yes';
		printLog("detected $origConfModules{corefix}{name} issue", 'L1', '[INFO]');
	}

	# if Huawei LTE ME936 device found
	my $lsusbHuawei936 = `lsusb -d 12d1:15bb`;
	if ($lsusbHuawei936 =~ /ME936/) {
		$origConfModules{huaweime936fix}{required} = 'yes';
		printLog("detected $origConfModules{huaweime936fix}{name} issue", 'L1', '[INFO]');
	}

	# if Huawei LTE ME906s device found
	my $lsusbHuawei906s = `lsusb -d 12d1:15c1`;
	if ($lsusbHuawei906s =~ /ME906s/) {
		$origConfModules{huaweime906sfix}{required} = 'yes';
		printLog("detected $origConfModules{huaweime906sfix}{name} issue", 'L1', '[INFO]');
	}

	# if Huawei LTE ME906s HP rebranded device found
	my $lsusbHuawei906sHP = `lsusb -d 03f0:a31d`;
	if ($lsusbHuawei906sHP =~ /hp/i) {
		$origConfModules{huaweime906shpfix}{required} = 'yes';
		printLog("detected $origConfModules{huaweime906shpfix}{name} issue", 'L1', '[INFO]');
	}

	# all notebooks require this
	if ( ($chassisType eq 'notebook') &&
		($ubuntuCodename =~ /focal/)) {
		$origConfModules{tuxedokeyboard}{required} = 'yes';
		printLog("detected $origConfModules{tuxedokeyboard}{name} issue", 'L1', '[INFO]');
	}

	# all notebooks require this
	# the temporary fix has to be removed for now as it causes boot delay issues
	# on some notebooks
	# not necessary on 24.04
	# when deleting this workaround, also delete the module entry from the config
	if (($chassisType eq 'notebook') && (!($distributionVersionID =~ /24.04/))) {
		if (-e '/etc/udev/rules.d/99-tuxedo-systemd-backlight-fix.rules') {
			printLog("former $origConfModules{systemdbacklightfix}{name} issue detected, removing it", 'L1', '[INFO]');
			$origConfModules{systemdbacklightfix}{required} = 'no';
		}
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /X170KM-G/) ||
		($boardname =~ /PCx0Dx_GN20/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxAGxx/) ||
		($boardname =~ /GMxTGxx/) ||
		($boardname =~ /GMxRGxx/) ||
		($boardname =~ /LAPQC71A/) ||
		($boardname =~ /PD5x_7xPNP_PNR_PNN_PNT/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /GMxPXxx/) ||
		($boardname =~ /GM6XGxX/)) {
		if (($ubuntuCodename =~ /bionic/) ||
			($ubuntuCodename =~ /focal/)) {
			$origConfModules{tuxedokeyboardite}{required} = 'yes';
			printLog("detected $origConfModules{tuxedokeyboardite}{name} issue", 'L1', '[INFO]');
		}
	}

	if ($ubuntuCodename =~ /jammy/) {
		$origConfModules{tuxedodrivers}{required} = 'yes';
		printLog("detected $origConfModules{tuxedodrivers}{name} issue", 'L1', '[INFO]');
		$origConfModules{tuxedokeyboardite}{required} = 'no';
		printLog("will remove obsolete $origConfModules{tuxedokeyboardite}{name} package", 'L1', '[INFO]');
		$origConfModules{tuxedokeyboard}{required} = 'no';
		printLog("will remove obsolete $origConfModules{tuxedokeyboard}{name} package", 'L1', '[INFO]');
	}

	# get vendor text from vendor ID:device ID
	my @tuxedonvmefixDevices = ('2646:2263');
	if ( findPciDevice($lspciOutput, @tuxedonvmefixDevices) ) {
		$origConfModules{tuxedonvmefix}{required} = 'yes';
		printLog("detected $origConfModules{tuxedonvmefix}{name} issue", 'L1', '[INFO]');
	}

	my $fingerprintLsUsb = `lsusb`;
	my @fingerprintRegExp = (
		qr/147e:100[0123]/,
		qr/147e:20(15|16|20)/,
		qr/147e:300[01]/,
		qr/147e:500[23]/,
		qr/0483:201[56]/,
		qr/1c7a:0603/);
	foreach my $fpkey (map { $fingerprintLsUsb =~ $_ } @fingerprintRegExp) {
		$origConfModules{fingerprintreader}{required} = 'yes';
		printLog("detected $origConfModules{fingerprintreader}{name} issue", 'L1', '[INFO]');
		last;
	}

	if ($boardname =~ m/N350TW/) {
		$origConfModules{tuxedorestoreaudiofix}{required} = 'yes';
		printLog("detected $origConfModules{tuxedorestoreaudiofix}{name} issue", 'L1', '[INFO]');
	}

	# get class codes from vendor ID
	my $nvidiaDevice = `lspci -nd 10de:`;
	if ($nvidiaDevice =~ /030[02]:/) {
		$origConfModules{nvidiadriver}{required} = 'yes';
		printLog("detected $origConfModules{nvidiadriver}{name} issue", 'L1', '[INFO]');
	}

	if ($boardname =~ m/NHxxRZQ/)	{
		# starting at kernel version 6.1 driver r8169 is included and supports the present device
		my $kernelVersionWithR8169 = '6.1';
		if (version_compare($kernelVersionWithR8169, $kernelRelease) == 1) {
			$origConfModules{r8168dkms}{required} = 'yes';
			printLog("detected $origConfModules{r8168dkms}{name} issue", 'L1', '[INFO]');
		}
	}

	if (($boardname =~ m/NL45PU2/) ||
		($boardname =~ m/NL57PU/))	{
		$origConfModules{r8168dkms}{required} = 'yes';
		printLog("detected $origConfModules{r8168dkms}{name} issue", 'L1', '[INFO]');
	}

	if (isDisplayPresent("SDC Model 41001 Serial Number 0")) {
		$origConfModules{tuxedooledbrt}{required} = 'yes';
		printLog("detected $origConfModules{tuxedooledbrt}{name} issue", 'L1', '[INFO]');
	}

	if (-e "/etc/default/apport") {
		# apportfix will always be installed as a workaround
		$origConfModules{apportfix}{required} = 'yes';
		printLog("detected $origConfModules{apportfix}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ m/GMxNGxx/) ||
		($boardname =~ m/GMxZGxx/)) {
		if (isDisplayPresent("BOE Model 2423 Serial Number 0") ||
			isDisplayPresent("BOE Model 2420 Serial Number 0")) {
			$origConfModules{amdgpubacklightauxoff}{required} = 'yes';
			printLog("detected $origConfModules{amdgpubacklightauxoff}{name} issue", 'L1', '[INFO]');
		}
	}

	if (($boardname =~ m/PHxTxX1/) ||
		($boardname =~ m/PH4TQx1/) ||
		($boardname =~ m/PHxTQx1/)) {
		$origConfModules{i915enablepsrfix}{required} = 'yes';
		printLog("detected $origConfModules{i915enablepsrfix}{name} issue", 'L1', '[INFO]');
	}

	# kernel
	if ($ubuntuCodename =~ /focal/ && $boardname =~ m/PD5x_7xPNP_PNR_PNN_PNT/) {
		printLog("kernel $origConfModules{kerneltuxedo2204}{name} should be installed", 'L1', '[INFO]');
		$origConfModules{kerneltuxedo2204}{required} = 'yes';
	} elsif ($ubuntuCodename =~ /focal/) {
		printLog("kernel $origConfModules{kerneltuxedo2004}{name} will be default", 'L1', '[INFO]');
		$origConfModules{kerneltuxedo2004}{required} = 'yes';
	} elsif ($ubuntuCodename =~ /jammy/) {
		printLog("kernel $origConfModules{kerneltuxedo2204}{name} will be default", 'L1', '[INFO]');
		$origConfModules{kerneltuxedo2204}{required} = 'yes';
	}

	if ($boardname =~ m/X170KM-G/) {
		$origConfModules{thunderboltbootdelayfix}{required} = 'yes';
		printLog("detected $origConfModules{thunderboltbootdelayfix}{name} issue", 'L1', '[INFO]');
	}

	if ((($boardname =~ m/NV4XMB,ME,MZ/) ||
		($boardname =~ m/PHxTQx1/) ||
		($boardname =~ m/PH4TQx1/)) && (-d '/etc/lightdm/')) {
		$origConfModules{lightdmlogindcheckgraphicalfix}{required} = 'yes';
		printLog("detected $origConfModules{lightdmlogindcheckgraphicalfix}{name} issue", 'L1', '[INFO]');
	}

	if ($boardname =~ m/GMxTGxx/) {
		$origConfModules{nvidiabacklightcontrolfix}{required} = 'yes';
		printLog("detected $origConfModules{nvidiabacklightcontrolfix}{name} issue", 'L1', '[INFO]');
	}

	if (($boardname =~ m/NV4XMB,ME,MZ/) ||
		($boardname =~ m/PHxTQx1/)) {
		$origConfModules{earlyloadbacklightcontrolfix}{required} = 'yes';
		printLog("detected $origConfModules{earlyloadbacklightcontrolfix}{name} issue", 'L1', '[INFO]');
	}

	my @r8125Devices = ('10ec:8125');
	if ( findPciDevice($lspciOutput, @r8125Devices) ) {
		$origConfModules{tuxedor8125dkms}{required} = 'yes';
		printLog("detected $origConfModules{tuxedor8125dkms}{name} issue", 'L1', '[INFO]');
	}

	# if cardreader Realtek RTS522A found
	my @cardreaderDevices = (qr/10ec:522a/); 
	if ( findPciDevice($lspciOutput, @cardreaderDevices) ) {
		$origConfModules{cardreaderfix}{required} = 'yes';
		printLog("detected $origConfModules{cardreaderfix}{name} issue", 'L1', '[INFO]');
	}

	if ($boardname =~ m/PF5LUXG/) {
		$origConfModules{samsungnvmefix}{required} = 'yes';
		printLog("detected $origConfModules{samsungnvmefix}{name} issue", 'L1', '[INFO]');
	}

	my @samsungNvme990Devices = ('144d:a80d');	
	if ((($boardname =~ m/NS5X_NS7XAU/i) || ($boardname =~ m/NS5X_7XAU/i)) &&
		( findPciDevice($lspciOutput, @samsungNvme990Devices) )) {
		$origConfModules{nvmequirkswitchtodeepsleepfix}{required} = 'yes';
		printLog("detected $origConfModules{nvmequirkswitchtodeepsleepfix}{name} issue", 'L1', '[INFO]');
	}


	# get vendor text from vendor ID:device ID
	my @intelgenXIIIpowerctlfixDevices = ('8086:1135');
	if ( findPciDevice($lspciOutput, @intelgenXIIIpowerctlfixDevices) ) {
		$origConfModules{intelgenXIIIpowerctlfix}{required} = 'yes';
		printLog("detected $origConfModules{intelgenXIIIpowerctlfix}{name} issue", 'L1', '[INFO]');
	}

	my $minPlasmaDesktopVersion = '5.25';
	my $currentPlasmaWorkspaceVersion = '';
	my $versionCompareResult;
	my $lspciGpus = '';
	$lspciGpus = `lspci -d ::0300`;
	if (countLinesInString($lspciGpus) >= 2) {
		printLog("more than 1 GPU found" , 'L2', '[DEBUG]');
		$currentPlasmaWorkspaceVersion = getPackageVersion('plasma-workspace');
		if ($currentPlasmaWorkspaceVersion ne '') {
			$versionCompareResult = version_compare($currentPlasmaWorkspaceVersion, $minPlasmaDesktopVersion);
			unless ( $versionCompareResult == -1 ) {
				$origConfModules{tuxedodgpurun}{required} = 'yes';
				printLog("detected $origConfModules{tuxedodgpurun}{name} issue", 'L1', '[INFO]');
			}
		} else {
			printLog("plasma-workspace version could not be determined", 'L2', '[INFO]');
		}
	} else {
		printLog("less than 2 GPU found" , 'L2', '[DEBUG]');
	}

	if (($boardname =~ m/PD5x_7xPNP_PNR_PNN_PNT/) ||
		($boardname =~ m/GMxTGxx/))	{
		$origConfModules{acpibacklightvideofix}{required} = 'yes';
		printLog("detected $origConfModules{acpibacklightvideofix}{name} issue", 'L1', '[INFO]');
	}
	if (($boardname =~ /PH4PRX1_PH6PRX1/) ||
   		($boardname =~ /PH4PG31/) ||
		($boardname =~ /PH6PG01_PH6PG71/)) {
		$origConfModules{disablegucfix}{required} = 'yes';
		printLog("detected $origConfModules{disablegucfix}{name} issue", 'L1', '[INFO]');
	}

	if ($completeDistVersion =~ /elementary OS 7.1/) {
		$origConfModules{elementaryosdkmspinningfix}{required} = 'yes';
		printLog("detected $origConfModules{elementaryosdkmspinningfix}{name} issue", 'L1', '[INFO]');
	}

	my @ath12kstandbyfixDevices = ('17cb:1107');
	if ( findPciDevice($lspciOutput, @ath12kstandbyfixDevices) ) {
		$origConfModules{ath12kstandbyfix}{required} = 'yes';
		printLog("detected $origConfModules{ath12kstandbyfix}{name} issue", 'L1', '[INFO]');
	}

	# tuxedoplasmaupgrade installation
	my $minPlasmaWorkspaceVersion = '6.0.0';
	readConfigIniValues();
	printLog("distribution: $distribution distributionVersion: $distributionVersion", 'L2', '[DEBUG]');
	if (($distribution =~ /TUXEDO OS/) && (($distributionVersion =~ /2 22\.04.*/) || ($distributionVersion =~ /3 22\.04.*/))) {
		printLog("found flavour compatible for plasma6", 'L2', '[DEBUG]');

		# check whether plasma6 is installed
		$currentPlasmaWorkspaceVersion = getPackageVersion('plasma-workspace');
		if ((defined($currentPlasmaWorkspaceVersion)) && ($currentPlasmaWorkspaceVersion ne '')) {
			$versionCompareResult = version_compare($currentPlasmaWorkspaceVersion, $minPlasmaWorkspaceVersion);
			unless ( $versionCompareResult == -1 ) {
				$plasma6Installed = 1;
				printLog("plasma 6 is installed", 'L2', '[DEBUG]');
			} else {
				$plasma6Installed = 0;
				printLog("current plasma version: $currentPlasmaWorkspaceVersion below '6'", 'L2', '[DEBUG]');
			}
		} else {
			$plasma6Installed = 0;
			printLog("could not determine plasma version", 'L2', '[DEBUG]');
		}

		# check whether tuxedoplasmaupgrade should be installed or if it
		# has been installed already in the past because we don't want to install it again
		if ($plasma6Installed == 0) {
			if (((! defined($configIniValues->{tuxedoplasmaupgrade}->{installed})) || ($configIniValues->{tuxedoplasmaupgrade}->{installed} ne '1')) && ($plasma6Installed != 1)) {
				printLog("tuxedoplasmaupgrade not defined in $configIniFile or value ne '1', means it has not been installed before", 'L2', '[DEBUG]');
				$origConfModules{tuxedoplasmaupgrade}{required} = 'yes';
				printLog("detected $origConfModules{tuxedoplasmaupgrade}{name} issue", 'L1', '[INFO]');
			} elsif ($configIniValues->{tuxedoplasmaupgrade}->{installed} eq '1') {
				printLog("tuxedo-plasma-upgrade has been installed already in the past", 'L2', '[DEBUG]');
			} else {
				printLog("tuxedoplasmaupgrade: undefined state detected", 'L2', '[DEBUG]');
			}
		}
	}

	if (($ubuntuCodename eq 'jammy') || ($distribution =~ /TUXEDO OS/)) {
		my @tuxedoyt6801Devices = ('1f0a:6801');
		if ( findPciDevice($lspciOutput, @tuxedoyt6801Devices) ) {
			$origConfModules{tuxedoyt6801}{required} = 'yes';
			printLog("detected $origConfModules{tuxedoyt6801}{name} issue", 'L1', '[INFO]');
		}
	}

	if ($distribution =~ /TUXEDO OS/) {
		$origConfModules{textboot}{required} = 'yes';
		printLog("detected $origConfModules{textboot}{name} issue", 'L1', '[INFO]');
	}
}



###############################################################################
# returns true if the PCI device or subdevice was found
# parameter is an array of PCI devices (RegExp are allowed)
#
sub findPciDevice {
	my ($lspciList, @pciDevices) = @_;
	my $pciDevice;
	foreach $pciDevice (@pciDevices) {
		if ($lspciList =~ /$pciDevice/) {
			return (1);
		}
	}
	return (0);
}












###############################################################################
###############################################################################
###############################################################################
#
# each configure one module from %confModules
# they set 'installed' status and $postConfModule trigger
#
###############################################################################
###############################################################################
###############################################################################





###############################################################################
# for touchpad problems
#
sub i8042noauxfix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'i8042.noaux');
}




###############################################################################
# deletes iommu=soft from grub
# was before for not being able to boot if system is on battery and used to set
# iommu=soft on grub
# affects BA15
# - PF5PU1G
#
sub nobootonbattery() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, 'remove', 0, 'iommu=soft');
}


###############################################################################
# Fix for some AMD devices where the xhci_hcd driver causes a jump out of
# suspend immediately on entering suspend
# - POLARIS1501A1650TI
# - POLARIS1501A2060
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - PULSE1401
# - PULSE1501
# - AURA1501/NL5xRU
# - EDUBOOK1502
#
sub amdxhcihcdusbquirksuspendfix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'xhci_hcd.quirks=1073741824');
}


###############################################################################
# Disables PSR for APX958
#
sub amdgpudisablepsr() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'amdgpu.dcdebugmask=0x10');
}


###############################################################################
# Enables activation of discrete NVIDIA graphics on devices with built-in AMD
# graphics. Also enables switching between the two with prime-select
# affects:
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - POLARIS1501A1650TI
# - POLARIS1501A2060
#
sub amdgpuwithnvidiafix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $fileName = '/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf';
	my $niceTime = getBackupFileTime();
	my $fileText = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"Section \"OutputClass\"\n".
		"\tIdentifier \"nvidia\"\n".
    	"\tMatchDriver \"nvidia-drm\"\n".
    	"\tDriver \"nvidia\"\n".
    	"\tOption \"AllowEmptyInitialConfiguration\"\n".
    	"\tModulePath \"/usr/lib/x86_64-linux-gnu/nvidia/xorg\"\n".
    	"\tOption \"PrimaryGPU\" \"Yes\"\n".
		"EndSection\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = write_file($fileName, {'err_mode' => 'carp'}, $fileText);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		$origConfModules{$module}{installed} = "yes";
		$origConfModules{$module}{upgraded} = "yes";
		addToConfiguredModules($module, "success");
	}
	if ($action eq 'remove') {
		if (removeWarningMessage("amd-gpu-with-nvidia-fix\n")) {
			printLog("removing $module", 'TL0', '[INFO]');
			unlink glob ("/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf_*");
			if (backupFile($fileName)) {
				unlink($fileName);
			} else {
				printLog('can\'t remove fix, it seems to be gone already', 'TL1', '[WARN]');
			}
			$origConfModules{$module}{installed} = 'no';
			$origConfModules{$module}{upgraded} = 'yes';
			addToConfiguredModules($module, 'removed');
		}
	}
}


###############################################################################
# TUXEDO Control Center application
#
sub tuxedocontrolcenter() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# Keyboard & keyboard backlight driver for TUXEDO notebooks
#
sub tuxedokeyboard() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}





###############################################################################
# Fix for TUXEDO Notebooks, fixes no keyboard present after suspend on
# - XC1711
# - XUX711
# - NH5xAx
# - AURA1501/NL5xRU
# - PB50_70DFx,DDx
# - N150CU
# - N141CU
# - XC15 
# - IBS15v6
# - EDUBOOK1502
#
sub nokeyboardaftersuspendfix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'i8042.reset', 'i8042.nomux', 'i8042.nopnp', 'i8042.noloop');
}


###############################################################################
# Fixes backlight issue with AUO Model 12701 and 21229 displays on
# - DX1708
# - P95_HP
# - P95_HR
# - P95_HP,HR,HQ
#
sub backlightfix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'i915.enable_dpcd_backlight=1');
}




###############################################################################
# Adds the TUXEDO repos to the system
#
sub tuxedorepos() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $thirdPartyMirrorsFile = '/etc/update-manager/release-upgrades.d/tuxedo.cfg';
	my $thirdPartyMirrorsFileText = "[ThirdPartyMirrors]\ntuxedo = https://deb.tuxedocomputers.com/ubuntu\n";

	# if this is a FAI-installation all repos should be already set correctly
	if ($FAI) {
		$origConfModules{$module}{installed} = "yes";
		$origConfModules{$module}{upgraded} = "yes";
		addToConfiguredModules($module, "success");
		return (1);
	}

	# create default repo list if it does not exist
	unless (-e '/etc/apt/sources.list') {
		open(FH, '>', '/etc/apt/sources.list');
		printLog('created /etc/apt/sources.list because it was not there', 'L2', '[WARN]');
		close(FH);
	}

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = createRepos(\%tuxedo_repos);
		addRepoKey();
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			# $thirPartyMirrorsFile is needed for Ubuntu's which use update-manager,
			# Mint uses mintUpdate instead
			unless (($ubuntuCodename =~ /jammy/) && ($distribution =~ /Linux Mint/)) {
				unless (-e $thirdPartyMirrorsFile) {
					printLog("$thirdPartyMirrorsFile not present, will create one ...", 'L0', '[WARN]');
					unless (write_file($thirdPartyMirrorsFile, {'err_mode' => 'carp'}, $thirdPartyMirrorsFileText)) {
						printLog("something is very fishy! can't create $thirdPartyMirrorsFile", 'L0', '[ERROR]');
					}
				}
			}
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on repos', 'L1', '[INFO]');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# repo updates have to be immediate for package installation
				if (!$FAI) {
					aptgetRefreshModule($module, 3);
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		backupFile('/etc/apt/sources.list');
		$retval = createRepos(\%tuxedo_repos);
		addRepoKey();
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			# $thirPartyMirrorsFile is needed for Ubuntu's which use update-manager,
			# Mint uses mintUpdate instead
			unless (($ubuntuCodename =~ /jammy/) && ($distribution =~ /Linux Mint/)) {
				unless (-e $thirdPartyMirrorsFile) {
					printLog("$thirdPartyMirrorsFile not present, will create one ...", 'L0', '[WARN]');
					unless (write_file($thirdPartyMirrorsFile, {'err_mode' => 'carp'}, $thirdPartyMirrorsFileText)) {
						printLog("something is very fishy! can't create $thirdPartyMirrorsFile", 'L0', '[ERROR]');
					}
				}
			}

			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on repos', 'L1', '[INFO]');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				aptgetRefreshModule($module, 3);
			}
		}
	}
	if ($action eq 'remove') {
		printLog("This is a prerequisite, removal is not possible for this module", 'TL0', '[WARN]');
	}
}


###############################################################################
# Adds the TUXEDO mirrors to the system
#
sub tuxedomirrors() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $retval3;

	# if this is a FAI-installation all repos should be already set correctly
	if ($FAI) {
		$origConfModules{$module}{installed} = "yes";
		$origConfModules{$module}{upgraded} = "yes";
		addToConfiguredModules($module, "success");
		return (1);
	}

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = createRepos(\%tuxedo_mirrors);
		$retval3 = cleanSourcesList($tuxedo_mirrors{$completeDistVersion}{mirrors}{filename});
		addRepoKey();
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if (($retval == 1) && ($retval3 == 0)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on mirrors', 'L1', '[INFO]');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				if (!$FAI) {
					aptgetRefreshModule($module, 3);
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("uprading $origConfModules{$module}{name}", 'L1', '[INFO]');
		backupFile('/etc/apt/sources.list');
		$retval = createRepos(\%tuxedo_mirrors);
		$retval3 = cleanSourcesList($tuxedo_mirrors{$completeDistVersion}{mirrors}{filename});
		addRepoKey();
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifications on mirrors', 'L1', '[INFO]');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				aptgetRefreshModule($module, 3);
			}
		}
	}
	if ($action eq 'remove') {
		printLog("This only removes the module from the list, manual intervention is necessary to remove the respective repository entries", 'TL0', '[INFO]');
		addToConfiguredModules($module, "removed");
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "yes";
		$origConfModules{$module}{required} = "no";
	}
}


###############################################################################
# Adds the core-fix for certain BIOS versions on certain mainboards
#
sub corefix() {
	my $module = shift;
	my $action = shift;
	if ($main::biosVersion eq "") {
		printLog("BIOS version empty", 'L1', '[WARN]');
		$origConfModules{$module}{installed} = "failed";
		addToConfiguredModules($module, "failed");
		return(0);
	}
	my $amlHookScript = 'tuxedo-corefix-clevo-nh5xax';
	my $amlHookScriptOrig = $shareDir.$amlHookScript;
	my $amlHookDirDest = '/etc/initramfs-tools/hooks/';
	my $amlHookScriptDest = $amlHookDirDest.$amlHookScript;
	my %amlFile = (
		'1.07.04NBC' => 'nh5xax-1.aml',
	);
	my $amlFileOrig = $shareDir.$amlFile{$main::biosVersion};
	my $amlFileDirDest = '/lib/firmware/tuxedo-corefix-clevo-nh5xax/';
	$amlFile{$main::biosVersion} =~ s/-\d*//;
	my $amlFileDest = $amlFileDirDest.$amlFile{$main::biosVersion};

	if ($action eq 'install') {
		if (($argValue{command} eq 'configure') || ($argValue{command} eq 'reconfigure')) {
			messageLongInstall();
			printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
			mkdir($amlFileDirDest, 0644) unless(-d $amlFileDirDest);
			copy($amlFileOrig, $amlFileDest);
			mkdir($amlHookDirDest, 0644) unless(-d $amlHookDirDest);
			copy($amlHookScriptOrig, $amlHookScriptDest);
			chmod 0700, $amlHookScriptDest;

			if ((-e $amlFileDest) and (-e $amlHookScriptDest)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$postConfProgram{updateInitramfs}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
			addToConfiguredModules($module, "nothingToDo");
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[WARN]');
	}
}



###############################################################################
# Fixes problem with Elantech touchpad
# affects InfinityBook 14 v2
# - X35R
#
sub elantechtouchpadfix() {
	my $module = shift;
	my $action = shift;
	editGrub( $module, $action, 'psmouse.elantech_smbus=0');
}



###############################################################################
# Creates a configuration to use Huawei-ME936
# - if USB device 12d1:15bb detected
#
sub huaweime936fix(){
	my $module = shift;
	my $action = shift;
	LTEModuleFix( $module, $action, 'huawei-me936', '12d1', '15bb', 3)
}



###############################################################################
# Creates a configuration to use Huawei-ME906
# - if USB device 12d1:15c1 detected
#
sub huaweime906sfix(){
	my $module = shift;
	my $action = shift;
	LTEModuleFix( $module, $action, 'huawei-me906s', '12d1', '15c1', 2)
}



###############################################################################
# Creates a configuration to use Huawei-ME906 HP rebranded
# - if USB device 03f0:a31d detected
#
sub huaweime906shpfix(){
	my $module = shift;
	my $action = shift;
	LTEModuleFix( $module, $action, 'huawei-me906s-hp', '03f0', 'a31d', 2)
}




###############################################################################
# Uniwill touchpad LED fix
#
sub tuxedotouchpadswitch() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# Kingston A2000 NVME drives freezing after deep APST sleep fix
#
sub tuxedonvmefix() {
	my $module = shift;
	my $action = shift;
	my %nvmeDevice;
	my $nvmeDir;
	my $output;
	my $retValue = 0;
	my $fwVersion = 'S5Z42109';
	my $nvmeUpdateSuccess = 0;
	my $nvmeFWPackageWasInstalled = 0;
	if (isPackageInstalled('tuxedo-nvme-fix')) {
		if (! deinstallSinglePackage('tuxedo-nvme-fix')) {
			printLog('obsolete package tuxedo-nvme-fix was successfully removed', 'L0', '[INFO]');
		} else {
			printLog('could not remove obsolete package tuxedo-nvme-fix, will try again next time', 'L0', '[WARN]');
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
			return (0);
		}
	}
	if (($action eq 'install') || ($action eq 'upgrade')) {
		while ( defined ($nvmeDir = glob '/sys/class/nvme/*' )) {
			$nvmeDevice{$nvmeDir}{'device'} = $nvmeDir;
			$nvmeDevice{$nvmeDir}{'device'} =~ /.*(nvme.*)/;
			$nvmeDevice{$nvmeDir}{'device'} = '/dev/'.$1;
			$nvmeDevice{$nvmeDir}{'model'} = readFirstLineOfFile("$nvmeDir/model");
			$nvmeDevice{$nvmeDir}{'subdevice'} = readFirstLineOfFile("$nvmeDir/device/subsystem_device");
			$nvmeDevice{$nvmeDir}{'subvendor'} = readFirstLineOfFile("$nvmeDir/device/subsystem_vendor");
			$nvmeDevice{$nvmeDir}{'firmware'} = readFirstLineOfFile("$nvmeDir/firmware_rev");
		}
		foreach $nvmeDir ( keys %nvmeDevice ) {
			if (($nvmeDevice{$nvmeDir}{model} =~ /SA2000M8(?:25|50|100)0G/) &&
				($nvmeDevice{$nvmeDir}{subdevice} =~ /0x2263/) &&
				($nvmeDevice{$nvmeDir}{subvendor} =~ /0x2646/)) {
				printLog("nvme device on $nvmeDevice{$nvmeDir}{'device'}", 'L1', '[INFO]');
				if ($nvmeDevice{$nvmeDir}{firmware} lt $fwVersion) {
					printLog("firmware upgrade required", 'L0', '[INFO]');
					# firmware upgrade is required
					if (! isPackageInstalled('nvme-cli')) {
						if (! installPackage('nvme-cli')) {
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
					}
					if (isPackageInstalled('a2000-s5z42109')) {
						$nvmeFWPackageWasInstalled = 1;
					}
					if (installPackage('a2000-s5z42109')) {
						printLog("upload firmware on $nvmeDevice{$nvmeDir}{'device'}", 'L1', '[INFO]');
						$output = `nvme fw-download $nvmeDevice{$nvmeDir}{'device'} -f /lib/firmware/a2000/$fwVersion.bin`;
						$retValue = $?/256;
						if ($retValue != 0) {
							printLog('firmware could not be uploaded!', 'L0', '[WARN]');
							printLog($output, 'L0', '[WARN]');
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						printLog("activate firmware on $nvmeDevice{$nvmeDir}{'device'}", 'L0', '[INFO]');
						$output = `nvme fw-activate $nvmeDevice{$nvmeDir}{'device'} --slot=1 --action=1`;
						$retValue = $?/256;
						if ($retValue != 0) {
							printLog('firmware could not be activated', 'TL0', '[WARN]');
							printLog($output, 'TL0', '[WARN]');
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						setRestartValues($module);
						$origConfModules{$module}{installed} = "yes";
						$origConfModules{$module}{upgraded} = "yes";
						printLog('nvme firmware was successfully updated', 'L0', '[INFO]');
						$nvmeUpdateSuccess = 1;
					} else {
						$origConfModules{$module}{installed} = "failed";
						addToConfiguredModules($module, "failed");
						return (0);
					}
				} else {
					printLog("firmware already installed on $nvmeDevice{$nvmeDir}{'device'}", 'L1', '[INFO]');
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
				}
			}
		}
		if ($nvmeUpdateSuccess) {
			addToConfiguredModules($module, "success");
		} else {
			addToConfiguredModules($module, "nothingToDo");
		}
		if (! $nvmeFWPackageWasInstalled) {
			deinstallSinglePackage('a2000-s5z42109');
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}




###############################################################################
# tuxedo-keyboard-ite
#
sub tuxedokeyboardite() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# fingerprint-reader
#
sub fingerprintreader() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packagefprintd;
	my $packagelibpam;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagefprintd = installPackage('fprintd');
		} else {
			$packagefprintd = 1;
		}
		if( ! isPackageInstalled('libpam-fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagelibpam = installPackage('libpam-fprintd');
		} else {
			$packagelibpam = 1;
		}

		if( $packagefprintd && $packagelibpam ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed", 'L0', '[INFO]');
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages', 'L1', '[INFO]');
	}
	if ($action eq 'remove') {
		if (removeWarningMessage("fingerprint-reader\n")) {
			my $counter = 0;
			if( isPackageInstalled('fprintd') ) {
				if (!deinstallSinglePackage('fprintd')) {
					$counter = $counter+1;
				}
			} else {
				$counter = $counter+1;
			}
			if( isPackageInstalled('libpam-fprintd') ) {
				if (!deinstallSinglePackage('libpam-fprintd')) {
					$counter = $counter+1;
				}
			} else {
				$counter = $counter+1;
			}
			if ($counter == 2) {
				$origConfModules{$module}{installed} = 'no';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, 'removed');
			} else {
				$origConfModules{$module}{installed} = 'yes';
				$origConfModules{$module}{upgraded} = 'no';
				addToConfiguredModules($module, 'remove failed');
			}
		}
	}
}




###############################################################################
# Rescans the pci bus to reactivate missing audio device
# - N350TW
#
sub tuxedorestoreaudiofix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $fileName = '/lib/systemd/system/restore-audiocards.service';
	my $fileText = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! \n".
		"[Unit]\n".
		"Description=Rescan the PCI-Bus for missed audio cards\n".
		"After=alsa-restore.service\n".
		"\n".
		"[Service]\n".
		"Type=oneshot\n".
		"RemainAfterExit=false\n".
		"ExecStart=/usr/bin/bash -c 'echo auto >> /sys/devices/pci0000:00/0000:00:1f.3/power/control'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/devices/pci0000:00/0000:00:1f.3/remove'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/bus/pci/rescan'\n".
		"\n".
		"[Install]\n".
		"WantedBy=multi-user.target\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval1 = write_file($fileName, {'err_mode' => 'carp'}, $fileText);
		$retval2 = system('systemctl --now enable restore-audiocards.service');
		if ($retval1 == 0 || $retval2 != 0) {
			if ($retval2 != 0) {
				printLog('systemd could not initialize restore-audiocards.service', 'L0', '[WARN]');
			}
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		printLog("no upgrade available yet for tuxedo-restore-audio-fix", 'L1', '[INFO]');
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}




###############################################################################
# tuxedo-drivers
#
sub tuxedodrivers() {
	my $module = shift;
	my $action = shift;
	if (debianPackageModule( $module, $action ) && ($action eq 'install')) {
		if (isPackageInstalled('tuxedo-keyboard')) {
			debianPackageModule( 'tuxedokeyboard', 'remove' );
		}
		if (isPackageInstalled('tuxedo-keyboard-ite')) {
			debianPackageModule( 'tuxedokeyboardite', 'remove');
		}
	}
}





###############################################################################
# kernel-tuxedo-20.04
#
sub kerneltuxedo2004() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		# clean up oldest tuxedo kernel in /boot (if not used)
		checkAndDeleteOldestTuxedoKernel();
		checkAndDeleteOldestRemnantLinuxHeader();

		installKernelFlavour('linux-tuxedo-20.04', \$instFailed, \$instDone);
		if ($instFailed > 0) {
			startTomteDelayed();
			addToConfiguredModules($module, "failed");
			$origConfModules{$module}{installed} = "failed";
		} elsif ($instDone > 0) {
			addToConfiguredModules($module, "success");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			setRestartValues($module);
		} else {
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}



###############################################################################
# kernel-tuxedo-22.04
#
sub kerneltuxedo2204() {
	my $module = shift;
	my $action = shift;
	my $instFailed = 0;
	my $instDone = 0;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		# clean up oldest tuxedo kernel in /boot (if not used)
		checkAndDeleteOldestTuxedoKernel();
		checkAndDeleteOldestRemnantLinuxHeader();

		installKernelFlavour('linux-tuxedo-22.04', \$instFailed, \$instDone);
		if ($instFailed > 0) {
			startTomteDelayed();
			addToConfiguredModules($module, "failed");
			$origConfModules{$module}{installed} = "failed";
		} elsif ($instDone > 0) {
			addToConfiguredModules($module, "success");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			setRestartValues($module);
		} else {
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}





###############################################################################
# nvidiadriver
# installs TUXEDO approved nvidia drivers and removes all the other ones
#
sub nvidiadriver() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageNvidiaDriver = 0;
	my $packageNvidiaPrime = 0;
	my $packagePythonAppindicator = 0;
	my $packagePythonCairo = 0;
	my $packagePythonGtk2 = 0;
	my $oldDriversRemoved = 0;
	my $output;
	my $nvidiaDriver510 = 'nvidia-driver-510';
	my $nvidiaDriver550 = 'nvidia-driver-550';

	if (($action eq 'install') || ($action eq 'upgrade')) {
		if ($completeDistVersion =~ /Ubuntu 18.04/) {
			if (isPackageInRepo($nvidiaDriver510)) {
				# deinstall other nvidia drivers
				$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver510);
			}

			# check if the package is already installed
			if( ! isPackageInstalled($nvidiaDriver510) ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver = installPackage($nvidiaDriver510);
			} else {
				setAptMark($nvidiaDriver510,'manual');
				$packageNvidiaDriver = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}
			if( ! isPackageInstalled('python-appindicator') ) {
				$wasInstalled = 0;
				$packagePythonAppindicator = installPackage('python-appindicator');
			} else {
				$packagePythonAppindicator = 1;
			}
			if( ! isPackageInstalled('python-cairo') ) {
				$wasInstalled = 0;
				$packagePythonCairo = installPackage('python-cairo');
			} else {
				$packagePythonCairo = 1;
			}
			if( ! isPackageInstalled('python-gtk2') ) {
				$wasInstalled = 0;
				$packagePythonGtk2 = installPackage('python-gtk2');
			} else {
				$packagePythonGtk2 = 1;
			}


			printLog("oldDriversRemoved: $oldDriversRemoved packageNvidiaDriver: $packageNvidiaDriver packageNvidiaPrime: $packageNvidiaPrime packagePythonAppIndicator: $packagePythonAppindicator packagePythonCairo: $packagePythonCairo packagePythonGtk2: $packagePythonGtk2", 'L2', '[DEBUG]');
			if( $oldDriversRemoved && $packageNvidiaDriver && $packageNvidiaPrime && $packagePythonAppindicator && $packagePythonCairo && $packagePythonGtk2 ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					addToConfiguredModules($module, "success");
					setRestartValues($module);
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		



		} elsif ($ubuntuCodename =~ /focal/) {
			if (isPackageInRepo($nvidiaDriver510)) {
				# deinstall other nvidia drivers
				$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver510);
			}

			# check if the package is already installed
			if( ! isPackageInstalled($nvidiaDriver510) ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver = installPackage($nvidiaDriver510);
			} else {
				setAptMark($nvidiaDriver510,'manual');
				$packageNvidiaDriver = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}

			if( $packageNvidiaDriver && $packageNvidiaPrime ) {
				# temporarily activated fix
				if ($FAI || ($origConfModules{$module}{installed} eq 'no')) {
					$output = `gpu-manager && prime-select nvidia`;
					printLog('selecting NVIDIA GPU: on', 'TL0', '[INFO]');
					printLog("$output", 'L2', '[DEBUG]');
				}
			}

			printLog("oldDriversRemoved: $oldDriversRemoved packageNvidiaDriver: $packageNvidiaDriver packageNvidiaPrime: $packageNvidiaPrime", 'L2', '[DEBUG]');
			if( $oldDriversRemoved && $packageNvidiaDriver && $packageNvidiaPrime ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					printLog("installed $origConfModules{$module}{name}", 'L1', '[INFO]');
					addToConfiguredModules($module, "success");
					setRestartValues($module);
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				printLog("$origConfModules{$module}{name} installation failed", 'L1', '[INFO]');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}




		} elsif ($ubuntuCodename =~ /jammy/) {
			my $tuxedoNvidiaDriver550 = 'tuxedo-nvidia-driver-550';

			# check if the drivers to install are actually available in repos
			if (isPackageInRepo( $tuxedoNvidiaDriver550 )) {
				# deinstall other nvidia drivers
				$oldDriversRemoved = deinstExcept('nvidia-driver-', $nvidiaDriver550);

				my $oldDriversRemovedCounter = deinstExcept('tuxedo-nvidia-driver-', $tuxedoNvidiaDriver550);
				$oldDriversRemoved += $oldDriversRemovedCounter;
				# check if the package is already installed
				if( ! isPackageInstalled($tuxedoNvidiaDriver550) ) {
					messageLongInstall();
					$wasInstalled = 0;
					setDkmsVerbose( 'nvidiadriver', 1 );
					$packageNvidiaDriver = installPackage($tuxedoNvidiaDriver550);
					setDkmsVerbose( 'nvidiadriver', 0 );
				} else {
					setAptMark($tuxedoNvidiaDriver550,'manual');
					$packageNvidiaDriver = 1;
				}
			} else {
				printLog("old nvidia packages will not be uninstalled as the required packages for the new driver $tuxedoNvidiaDriver550 can't be found in the repositories", 'L0', '[WARN]');
			}

			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}

			if( $packageNvidiaDriver && $packageNvidiaPrime ) {
				# temporarily activated fix
				if ($FAI || ($origConfModules{$module}{installed} eq 'no')) {
					$output = `gpu-manager && prime-select nvidia`;
					printLog('selecting NVIDIA GPU: on', 'TL0', '[INFO]');
					printLog("$output", 'L2', '[DEBUG]');
				}
			}

			printLog("oldDriversRemoved: $oldDriversRemoved packageNvidiaDriver: $packageNvidiaDriver packageNvidiaPrime: $packageNvidiaPrime", 'L2', '[DEBUG]');
			if( $oldDriversRemoved && $packageNvidiaDriver && $packageNvidiaPrime ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
					addToConfiguredModules($module, "nothingToDo");
				} else {
					printLog("installed $origConfModules{$module}{name}", 'L1', '[INFO]');
					addToConfiguredModules($module, "success");
					setRestartValues($module);
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				printLog("$origConfModules{$module}{name} installation failed", 'L1', '[WARN]');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("unknown distribution/flavour, can't install nvidia drivers", 'TL0', '[WARN]');
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}




###############################################################################
# Installs Linux device driver for several Realtek Ethernet controllers
#
sub r8168dkms() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# Installs package tuxedo-oled-brt to control the brightness of OLED displays
# using xrandr and dbus
# The original program is from System76 https://github.com/pop-os/system76-oled
#
sub tuxedooledbrt() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# deactivates apport reporting
#
sub apportfix() {
	my $module = shift;
	my $action = shift;
	my $oldApportLine = 'default=1';
	my $newApportLine = 'default=0';
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');

		if (isLineInFile('/etc/default/apport', 'enabled=1')) {
			$retval = edit_file { s/enabled=1/enabled=0/g } '/etc/default/apport', {'err_mode' => 'carp'};
			if ($retval == 1) {
				printLog('apport has been disabled in /etc/default/apport', 'L0', '[INFO]');
				#`service apport stop`;
				#printLog("service apport stop returned: $?", 'L2', '[DEBUG]');
				#`systemctl disable apport.service`;
				#printLog("systemctl disable apport.service returned: $?", 'L2', '[DEBUG]');
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} elsif (isLineInFile('/etc/default/apport', 'enabled=0')) {
			printLog('apport was already disabled in /etc/default/apport', 'L1', '[DEBUG]');
			#`service apport stop`;
			#printLog("service apport stop returned: $?", 'L2', '[DEBUG]');
			#`systemctl disable apport.service`;
			#printLog("systemctl disable apport.service returned: $?", 'L2', '[DEBUG]');
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
		} else {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		}
	}
	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}





###############################################################################
# Fixes backlight issue with BOE Model 2423 Serial Number 0 displays on
# - GMxNGxx
#
sub amdgpubacklightauxoff() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'amdgpu.backlight=0' );
}





###############################################################################
# Provides better battery life
# adds two parameters and deletes an old one in case it is present
#
sub i915enablepsrfix() {
	my $module = shift;
	my $action = shift;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		edit_file { s/i915\.enable_psr=0//g } '/etc/default/grub', {'err_mode' => 'carp'};
	}
	grubModuleEdit( $module, $action, 0, 'i915.tuxedo_disable_psr2=1', 'i915.enable_psr=1');
}




###############################################################################
# for reducing the timeout on loading the thunderbolt kernel module when
# booting the system
# - X170KM-G
# adds some parameters and deletes one if found
#
sub thunderboltbootdelayfix() {
	my $module = shift;
	my $action = shift;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		edit_file { s/thunderbolt.tuxedo_icm_driver_ready_timeout=2000//g } '/etc/default/grub', {'err_mode' => 'carp'};
	}
	grubModuleEdit( $module, $action, 0, 'modprobe.blacklist=thunderbolt');
}



###############################################################################
# inserts a parameter to start lightdm after the windowmanager has started
#
sub lightdmlogindcheckgraphicalfix() {
	my $module = shift;
	my $action = shift;
	my $lightdmLine = 'logind-check-graphical=true';
	my $lightdmCheckGraphicalDir = '/etc/lightdm/lightdm.conf.d/';
	my $lightdmCheckGraphicalFile = $lightdmCheckGraphicalDir.'99_tuxedo.conf';

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		unless (-d $lightdmCheckGraphicalDir) {
			unless (mkdir $lightdmCheckGraphicalDir) {
				printLog("could not create directory $lightdmCheckGraphicalDir", 'TL0', '[ERROR]');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
		if (-e $lightdmCheckGraphicalFile) {
			unless (isTextInFile($lightdmCheckGraphicalFile, '[LightDM]') && isTextInFile($lightdmCheckGraphicalFile, 'logind-check-graphical=true')) {
				if (write_file($lightdmCheckGraphicalFile, {'err_mode' => 'carp'}, "[LightDM]\nlogind-check-graphical=true")) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "success");
				} else {
					$origConfModules{$module}{installed} = "failed";
					addToConfiguredModules($module, "failed");
					return (0);
				}
			}
		} else {
			if (write_file($lightdmCheckGraphicalFile, {'err_mode' => 'carp'}, "[LightDM]\nlogind-check-graphical=true")) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
	}

	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}



###############################################################################
# For functioning backlight control on Nvidia GPU's
#
# - GMxTGxx
#
# removes some old parameters if present
#
sub nvidiabacklightcontrolfix() {
	my $module = shift;
	my $action = shift;

	if (($action eq 'install') || ($action eq 'upgrade')) {
		edit_file { s/ NVreg_RegistryDwords=EnableBacklightHandler=0//g } '/etc/default/grub', {'err_mode' => 'carp'};
		edit_file { s/ NVreg_RegistryDwords=EnableBrightnessControl=1//g } '/etc/default/grub', {'err_mode' => 'carp'};
	}
	grubModuleEdit( $module, $action, 0, 'nvidia.NVreg_RegistryDwords=EnableBacklightHandler=0', 'nvidia.NVreg_RegistryDwords=EnableBrightnessControl=1', 'i915.enable_dpcd_backlight=0');
}



###############################################################################
# inserts a parameter to start lightdm after the windowmanager has started
#
sub earlyloadbacklightcontrolfix() {
	my $module = shift;
	my $action = shift;
	my $elbcLine = 'softdep nvidia pre: i915';
	my $elbcDir = '/etc/modprobe.d/';
	my $elbcFile = $elbcDir.'tuxedo_early_load_backlight_control_fix.conf';

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		unless (-d $elbcDir) {
			unless (mkdir $elbcDir) {
				printLog("could not create directory $elbcDir", 'TL0', '[WARN]');
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
		if (-e $elbcFile) {
			unless (isTextInFile($elbcFile, $elbcLine)) {
				if (write_file($elbcFile, {'err_mode' => 'carp'}, $elbcLine)) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "success");
				} else {
					$origConfModules{$module}{installed} = "failed";
					addToConfiguredModules($module, "failed");
					return (0);
				}
			}
		} else {
			if (write_file($elbcFile, {'err_mode' => 'carp'}, $elbcLine)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
				return (0);
			}
		}
	}

	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}



###############################################################################
# Installs the newest driver for RTL8125 2.5GbE Controller
# Solves some ethernet problems/hang/slow connection
#
sub tuxedor8125dkms() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}



###############################################################################
# Forces cardreader Realtek RTS522A to stay on when device goes into idle
# - if USB device 0x10ec:0x522a detected
#
sub cardreaderfix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $fileName1 = '/etc/udev/rules.d/45-tuxedo-force-realtek-522a-cardreader-on.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR{vendor}==\"0x10ec\", ATTR{device}==\"0x522a\", RUN+=\"/bin/sh -c 'echo on > /sys/bus/pci/devices/\$kernel/power/control'\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval1 = write_file($fileName1, {'err_mode' => 'carp'}, $fileText1);
		if ($retval1 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[INFO]');
	}
}



###############################################################################
# Pulse gen 2 in combination with some Samsung SSDs do not wake up from sleep
# This workaround allows suspend (s2idle) wake-up to function
#
sub samsungnvmefix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $fileName = '/lib/udev/rules.d/99-pulse1502-samsung-nvme.rules';
	my $niceTime = getBackupFileTime();
	my $fileText = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa80a\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa808\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa80c\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR\{vendor}==\"0x144d\", ATTR\{device}==\"0xa809\", RUN+=\"/bin/sh -c 'echo 0 | tee /sys/bus/pci/devices/\$kernel/d3cold_allowed'\"\n";
	if ($action eq 'install') {
		if (isLineInFile($fileName, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa80a", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"') &&
			isLineInFile($fileName, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa808", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"') &&
			isLineInFile($fileName, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa80c", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"') &&
			isLineInFile($fileName, 'SUBSYSTEM=="pci", ACTION=="add", ATTR\{vendor}=="0x144d", ATTR\{device}=="0xa809", RUN\+="\/bin\/sh -c \'echo 0 \| tee \/sys\/bus\/pci\/devices\/\$kernel\/d3cold_allowed\'"')) {
			printLog("entries for samsungnvmefix are already present", 'TL2', '[DEBUG]');
			$localConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = "yes";
			$configuredModules{$module} = 'nothingToDo';
		} else {
			printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
			$retval = write_file($fileName, {'err_mode' => 'carp'}, $fileText);
			if ($retval == 0) {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				setRestartValues($module);
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = write_file($fileName, {'err_mode' => 'carp'}, $fileText);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# InfinityBook 15/17 Gen8 in combination with some Samsung SSDs
#
sub nvmequirkswitchtodeepsleepfix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'mem_sleep_default=deep' );
}




###############################################################################
# Commandline tool and KDE context menu entries to run programms on dGPU while
# in on-demand mode
#
sub tuxedodgpurun() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}




###############################################################################
# Fixes power control problems with Intel Gen13 devices
# Manually sets power control to 'auto' to allow sleeping when not in use
# - if PCI USB device 0x8086:0x1135 detected
#
sub intelgenXIIIpowerctlfix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $fileName1 = '/etc/udev/rules.d/99-intel-rpl-powerctl.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"SUBSYSTEM==\"pci\", ACTION==\"add\", ATTR{vendor}==\"0x8086\", ATTR{device}==\"0x1135\", RUN+=\"/bin/sh -c 'echo auto | tee /sys/bus/pci/devices/\$kernel/power/control'\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval1 = write_file($fileName1, {'err_mode' => 'carp'}, $fileText1);
		if ($retval1 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
		printLog("remove is not implemented yet for this module", 'TL0', '[WARN]');
	}
}



###############################################################################
# Boot delays/freezes in nvidia modes
#
sub acpibacklightvideofix() {
	my $module = shift;
	my $action = shift;
	grubModuleEdit( $module, $action, 0, 'acpi_backlight=video');
}



###############################################################################
# disabled GuC submission while keeping HuC on Intel iGPU 
#
sub disablegucfix() {
	my $module = shift;
	my $action = shift;
	my @kernelParameters = ('i915.enable_guc=2');
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = insertGrub($module, \@kernelParameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage("disable-guc-fix\n")) {
			removeKernelParameters($module, 0, @kernelParameters);
		}
	}
}




###############################################################################
# pinning on Elementary OS to ensure we provide the correct dkms version
#
sub elementaryosdkmspinningfix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $fileName = '/etc/apt/preferences.d/tuxedo-computers';
	my $fileText = 	"# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!!\n".
					"Package: dkms\n".
					"Pin: release a=tuxedo,n=jammy\n".
					"Pin-Priority: 1000\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval = write_file($fileName, {'err_mode' => 'carp'}, $fileText);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		if (-e $fileName) {
			if (removeWarningMessage("elementaryos-dkms-pinning-fix\n")) {
				printLog("removing $module", 'TL0', '[INFO]');
				if (unlink($fileName)) {
					printLog("$origConfModules{$module}{name} removed", 'TL0', '[INFO]');
				} else {
					printLog('can\'t remove fix', 'TL0', '[ERROR]');
				}
				$origConfModules{$module}{installed} = 'no';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, 'removed');
			}
		} else {
			$origConfModules{$module}{installed} = 'no';
			$origConfModules{$module}{upgraded} = 'yes';
			addToConfiguredModules($module, 'removed');
			printLog("$origConfModules{$module}{name} was already removed", 'TL0', '[INFO]');
		}
	}
}



###############################################################################
# Boot delays/freezes in nvidia modes
#
sub ath12kstandbyfix() {
	my $module = shift;
	my $action = shift;
	my $content = <<'END_TXT';
#!/bin/sh
# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!!

case $1 in
  pre)
    rmmod ath12k
    ;;
  post)
    modprobe ath12k
    ;;
esac
END_TXT
	createFileModule( $module, $action, '/usr/lib/systemd/system-sleep/tuxedo-ath12k-standby-fix', $content, "+x");
}




###############################################################################
# TUXEDO plasma6
#
sub tuxedoplasmaupgrade() {
	my $module = shift;
	my $action = shift;
	if ($action =~ /install/) {
		if ((!defined($configIniValues->{tuxedoplasmaupgrade}->{installed})) ||
			($configIniValues->{tuxedoplasmaupgrade}->{installed} ne '1')) {
			if ( isPackageInstalled($origConfModules{$module}{name}) ) {
				$configIniValues->{tuxedoplasmaupgrade}->{installed} = '1';
				writeConfigIniFile();
			} else {
				if (debianPackageModule( 'tuxedoplasmaupgrade', $action )) {
					$configIniValues->{tuxedoplasmaupgrade}->{installed} = '1';
					writeConfigIniFile();
				}
			}
		}
	} else {
		printLog("other actions besides install are not possible for this module", 'L2', '[DEBUG]');
	}
}



###############################################################################
# Installs Linux device driver for Ethernet controller Motorcomm YT6801
#
sub tuxedoyt6801() {
	my $module = shift;
	my $action = shift;
	debianPackageModule( $module, $action );
}




###############################################################################
# solves black screen after plasma6 upgrade
#
sub textboot() {
	my $module = shift;
	my $action = shift;
	my @splashParameter = ('splash');
	my @nosplashParameter = ('nosplash');
	my $retPar;
	if (($action eq 'install') || ($action eq 'upgrade')) {
		removeKernelParameters($module, 1, @splashParameter);
		grubModuleEdit($module, $action, 0, @nosplashParameter);
	}
	if ($action eq 'remove') {
		grubModuleEdit( $module, $action, 1, @nosplashParameter);
		$retPar = insertGrub($module, \@splashParameter);
		if ($retPar >= 1) {
			printLog("@splashParameter successfully inserted into grub", 'L2', '[DEBUG]');
			block('text-boot');
		} else {
			printLog("something went wrong while inserting @splashParameter into grub", 'L2', '[ERROR]');
		}
	}
}



















###############################################################################
###############################################################################
###############################################################################
# subs for tuxedorepos & tuxedomirrors
#

###############################################################################
# Adds the TUXEDO repos to the system with public key
# returns 2 if successful and changes to repos were made
# returns 1 if successful and no changes to repos
# returns 0 if failed
#
sub createRepos {
	my %repos = %{$_[0]};
	my $DH;
	my $sourceline;
	my $modified = 0;
	my $sourcesListDir = '/etc/apt/';
	my $sourcesListDirD = '/etc/apt/sources.list.d/';
	my $sourcesFileName = $sourcesListDir.'sources.list';

	my $distroKey = exists($repos{$completeDistVersion}) ? $completeDistVersion : $ubuntuCodename;

	# if either testdeb or testmirrors exist, leave everything as it is
	if (exists $repos{$distroKey}{deb}) {
		printLog("deb repos detected", 'TL2', '[DEBUG]');
		if (isLineInFile('/etc/apt/sources.list.d/tuxedo-computers.list', '^deb https?:\/\/testdeb.*')) {
			printLog('testing environment detected, leaving repos as they are', 'TL2', '[DEBUG]');
			return (1);
		}
	} elsif (exists $repos{$distroKey}{mirrors}) {
		printLog("mirror repos detected", 'TL2', '[DEBUG]');
		if (isLineInFile('/etc/apt/sources.list', '^deb https?:\/\/testmirrors.*')) {
			printLog('testing environment detected, leaving repos as they are', 'TL2', '[DEBUG]');
			return (1);
		}
	}

	if (!-d $sourcesListDir) {
		printLog("no $sourcesListDir found (something's really wrong)", 'TL0', '[ERROR]');
		# no apt directory, somethings fishy
		return (0);
	}
	if (!-d $sourcesListDirD) {
		printLog("no $sourcesListDirD found, creating one", 'TL0', '[WARN]');
		mkdir($sourcesListDirD);
	}

	# workaround for possible old entries in sources list
	# do NOT add more distributions/flavours here as this is meant only for
	# old installations where those entries might still exist
	if ($ubuntuCodename ne 'jammy') {
		if(-e '/etc/apt/sources.list.d/tuxedo-computers.list'){
			edit_file { s/deb http:\/\/deb.tuxedocomputers.com\/ubuntu bionic main//g } '/etc/apt/sources.list.d/tuxedo-computers.list', {'err_mode' => 'carp'};
			edit_file { s/deb http:\/\/deb.tuxedocomputers.com\/ubuntu focal main//g } '/etc/apt/sources.list.d/tuxedo-computers.list', {'err_mode' => 'carp'};
			edit_file { s/# Added by TUXEDO Tomte//g } '/etc/apt/sources.list.d/tuxedo-computers.list', {'err_mode' => 'carp'};
		}

		if(-e '/etc/apt/sources.list.d/graphics-tuxedo.list'){
			edit_file { s/# Added by TUXEDO Tomte//g } '/etc/apt/sources.list.d/graphics-tuxedo.list', {'err_mode' => 'carp'};
			edit_file { s/deb http:\/\/graphics.tuxedocomputers.com\/ubuntu focal main//g } '/etc/apt/sources.list.d/graphics-tuxedo.list', {'err_mode' => 'carp'};
		}

		if(-e '/etc/apt/sources.list.d/oibaf-tuxedo.list'){
			edit_file { s/# Added by TUXEDO Tomte//g } '/etc/apt/sources.list.d/oibaf-tuxedo.list', {'err_mode' => 'carp'};
			edit_file { s/deb http:\/\/oibaf.tuxedocomputers.com\/ubuntu focal main//g } '/etc/apt/sources.list.d/oibaf-tuxedo.list', {'err_mode' => 'carp'};
		}
	} else {
		if(-e '/etc/apt/sources.list.d/tuxedo-computers.list'){
			edit_file { s/deb http:\/\/deb.tuxedocomputers.com\/ubuntu jammy main//g } '/etc/apt/sources.list.d/tuxedo-computers.list', {'err_mode' => 'carp'};
			edit_file { s/# Added by TUXEDO Tomte//g } '/etc/apt/sources.list.d/tuxedo-computers.list', {'err_mode' => 'carp'};
		}
		if (-e '/etc/apt/sources.list.d/graphics-tuxedo.list') {
			if (unlink('/etc/apt/sources.list.d/graphics-tuxedo.list')) {
				printLog('deleted /etc/apt/sources.list.d/graphics-tuxedo.list', 'TL1', '[INFO]');
			}
		}
		if (-e '/etc/apt/sources.list.d/oibaf-tuxedo.list') {
			if (unlink('/etc/apt/sources.list.d/oibaf-tuxedo.list')) {
				printLog('deleted /etc/apt/sources.list.d/oibaf-tuxedo.list', 'TL1', '[INFO]');
			}
		}
	}

	my $repoFileText = '';
	foreach my $key (keys %{ $repos{$distroKey} }) {
		# each line
		printLog("key: $key distroKey: $distroKey", 'L2', '[DEBUG]');
		if ($key ne 'name') {
			# hack to set the TUXEDO plasma repos to the correct values
			if ($plasma6Installed) {
				printLog("plasma6: yes", 'L2', '[DEBUG]');
				if (($key eq 'plasma6txos') || ($key eq 'plasma6plasma') || ($key eq 'deb') || ($key eq 'mirrors')) {
					$repoFileText = join "\n", @{$repos{$distroKey}{$key}{content}};
				}
			} elsif ($distribution =~ /TUXEDO OS/) {
				printLog("plasma6: no", 'L2', '[DEBUG]');
				if (($key eq 'nonplasma6txos') || ($key eq 'nonplasma6plasma') || ($key eq 'deb') || ($key eq 'mirrors')) {
					$repoFileText = join "\n", @{$repos{$distroKey}{$key}{content}};
				}
			} else {
				printLog("key: $key", 'L2', '[DEBUG]');
				printLog("content: @{$repos{$distroKey}{$key}{content}}", 'L2', '[DEBUG]');
				$repoFileText = join "\n", @{$repos{$distroKey}{$key}{content}};
			}
			printLog("repofiletext: $repoFileText", 'L2', '[DEBUG]');
			
			if ($repoFileText ne '') {
				my $fileText = "# tuxedo-tomte will overwrite this file if you modify anything,\n".
					"# we recommend you to put your own modifications into some other file\n".
					"# e.g. /etc/apt/sources.list.d/own-modifications.list\n".
					$repoFileText . "\n";

				my $noChangesNeeded = -e $repos{$distroKey}{$key}{filename};
				if($noChangesNeeded) {
					my $fileContentText = read_file($repos{$distroKey}{$key}{filename}, 'err_mode' => 'carp');
					$noChangesNeeded = $fileContentText eq $fileText;
				}

				if($noChangesNeeded){
					printLog("repo file $repos{$distroKey}{$key}{filename} found and with correct content", 'L2', '[DEBUG]');
				} else {
					printLog("$repos{$distroKey}{$key}{filename} incorrect", 'L0', '[WARN]');
					printLog("recreating $repos{$distroKey}{$key}{filename}", 'L0', '[INFO]');

					if (write_file($repos{$distroKey}{$key}{filename}, {'err_mode' => 'carp'}, $fileText) ) {
						$modified += 1;
						printLog("wrote file: $repos{$distroKey}{$key}{filename}", 'L0', '[INFO]');
					} else {
						printLog("could not create file: $repos{$distroKey}{$key}{filename}", 'L0', '[ERROR]');
					}
				}
			}
			$repoFileText = '';
		}
	}
	return ($modified+1);
}



###############################################################################
# checks if the repo key is installed by comparing its content
# adds the repo key for TUXEDO repos if not present
# returns 1 if package is installed or was installed successfully
# returns 0 if not
#
sub addRepoKey {
	my $output;
	my $retval;
	my $errorCode;
	my $outputKey;
	my $counter = 0;
	my $pmLocked;
	# install TUXEDO keyring for repositories
	unless (isPackageInstalled("tuxedo-archive-keyring")) {
		printLog("TUXEDO keyring is not installed", 'L0', '[WARN]');
		if (checkNetwork(15, 1)) {
			$outputKey = `wget -r -nd --no-parent -P /tmp/ -A 'tuxedo-archive-keyring*.deb' https://deb.tuxedocomputers.com/ubuntu/pool/main/t/tuxedo-archive-keyring/`;
			deactivatePackagekit();
			# wait a bit for package management to settle down
			while ($counter < 15) {
				$counter++;
				my $command = $consoleLanguage.'apt-get -y --allow-unauthenticated -o Dpkg::lock::timeout=0 install /tmp/tuxedo-archive-keyring* 2>/dev/null';
				if (unlockPM("$command") && (isPMlocked() == 0)) {
					printLog("executing: $command", 'L2', '[DEBUG]');
					$outputKey = `$command`;
					$errorCode = $?/256;
					lockPM();
					if ($errorCode != 0) {
						printLog("error code apt-get: $errorCode", 'L2', '[ERROR]');
						printLog("output apt-get: $outputKey", 'L2', '[ERROR]');
					} else {
						printLog("no errors installing keyrings", 'L2', '[INFO]');
						last;
					}
				} else {
					printLog("something is wrong while looking for locks for keyring installation", 'L0', '[ERROR]');
				}
				printLog("problem installing keyring, trying again later", 'L2', '[WARN]');
				sleep(1);
			}
			if (isPackageInstalled("tuxedo-archive-keyring")) {
				printLog("TUXEDO keyring installed successfully", 'L2', '[INFO]');
				return (1);
			} else {
				printLog("The TUXEDO repository key could not be installed!", 'TL0', '[ERROR]');
				unless ($LiveISO) {
					printLog("Tomte will try again in few minutes or after reboot or if startet manually with:\nsudo tomte configure all", 'TL0', '[INFO]');
				}
				startTomteDelayed(__("Tomte will try again in a few minutes or after reboot or when activated manually with: sudo tomte configure all"));
				return (0);
			}
		} else {
			printLog("no network connection found! the TUXEDO repository keys can't be installed", 'TL0', '[WARN]');
			unless ($LiveISO) {
				printLog("Tomte will try again in a few minutes or after reboot or if startet manually with:\nsudo tomte configure all", 'TL0', '[INFO]');
			}
			startTomteDelayed(__("Tomte will try again in a few minutes or after reboot or when activated manually with: sudo tomte configure all"));
			return (0);
		}
	}
	return (1);
}



###############################################################################
# comment out anything else on sources.list which has
# deb mirrorurl and not tuxedocomputers
# returns 0 if nothing was changed
# returns 1 if modifications were made
#
sub cleanSourcesList {
	my $FHsource;
	my @sourceLines;
	my $sourceLine;
	my $sourcesListFile = '/etc/apt/sources.list';
	my $modified = 0;
	my $tomteMessage = '# tuxedo-tomte commented out all entries at installation, any TUXEDO repositories will be automatically deleted';

	# read all the lines
	if ( (-e $sourcesListFile) && open($FHsource, "<", $sourcesListFile)) {
		chomp(@sourceLines = <$FHsource>);
		close $FHsource;
		# open for writing
		if (!-e $sourcesListFile) {
			return (0);
		}
		if (open($FHsource, ">", $sourcesListFile)) {
			unless (grep( /$tomteMessage/, @sourceLines )) {
				# no backup for the file as it only comments out lines
				print $FHsource "$tomteMessage\n";
			}
			printLog("tuxedomirrors version: $localConfModules{'tuxedomirrors'}{version}", 'L2', '[DEBUG]');
			# in case this is an upgrade from a version without this feature or a first time installation
			if (-e $tomteFirstInstallFile) {
				printLog("first time installation file exists !!!", 'L2', '[DEBUG]');
			}
			if ((($localConfModules{'tuxedomirrors'}{version} + 0) < 5) || (-e $tomteFirstInstallFile)) {
				printLog("old tuxedomirrors module installed", 'L2', '[INFO]');
				foreach $sourceLine (@sourceLines) {
					if (commentOut(\$sourceLine)) {
						$modified = 1;
					}
					unless ($sourceLine =~ /mirrors\.tuxedocomputers\./) {
						print $FHsource "$sourceLine\n";
					}
				}
			} else {
				printLog("current tuxedomirrors module is already installed", 'L2', '[INFO]');
				# remove all tuxedo mirrors entries
				foreach $sourceLine (@sourceLines) {
					unless ($sourceLine =~ /mirrors\.tuxedocomputers\./) {
						print $FHsource "$sourceLine\n";
					}
				}
			}
			close $FHsource;
		} else {
			printLog("file $sourcesListFile not found", 'L0', '[ERROR]');
		}
	} else {
		printLog("file $sourcesListFile not found", 'L0', '[ERROR]');
	}
	return ($modified);
}



###############################################################################
# puts a '#' in front of the passed string and returns it
#
sub commentOut {
	my $line = shift;
	if (${$line} =~ /^#/) {
		return (0);
	} else {
		${$line} = "# ${$line}";
		return (1);
	}
}






###############################################################################
# package handling
#


###############################################################################
# get packagekit status from systemd getSystemStatus(systemdmodule)
# returns 'active', 'inactive' or '0' if no status could be retrieved
#
sub getSystemdState {
	my $systemdModule = shift;
	if ($FAI) {
		return (0);
	}
	my $systemdCmd = "systemctl is-active $systemdModule";
	my $systemdReturn = `$systemdCmd`;
	$systemdReturn =~ s/\s+//g;
	printLog("systemd return for $systemdModule: $systemdReturn", 'L2', '[INFO]');
	if ($systemdReturn =~ /^active/) {
		return 'active';
	} elsif ($systemdReturn =~ /^inactive/) {
		return 'inactive';
	} else {
		return (0);
	}
}



###############################################################################
# get packagekit is-enabled from systemd getSystemdEnabled(systemdmodule)
# returns the value from 'systemctl is-enabled'
#
sub getSystemdEnabled {
	my $systemdModule = shift;
	if ($FAI) {
		return (0);
	}
	my $systemdCmd = "systemctl is-enabled $systemdModule";
	my $systemdReturn = `$systemdCmd`;
	$systemdReturn =~ s/\s+//g;
	printLog("systemd returns: $systemdReturn", 'L2', '[INFO]');
	return ($systemdReturn);
}



###############################################################################
# sends a command to the module by systemd
# commandSystemdModule(command, module)
# eg: mask --now, unmask, start, stop, enable, disable
#
sub commandSystemdModule {
	my ($command, $systemdModule) = @_;
	my $systemdCmd = "systemctl $command $systemdModule";
	my $systemdReturn = `$systemdCmd`;
	printLog("systemd returns: $systemdReturn", 'L2', '[INFO]');
}



###############################################################################
# sets the systemd module to inactive and masks it
# returns 1 if successful, 0 if not
# does nothing if packagekitState is set to "inactive"
#
sub deactivatePackagekit {
	if ($packagekitState eq 'inactive') {
		return (1);
	}
	if (getSystemdState('packagekit') eq 'active') {
		printLog("packagekit is active => deactivating ...", 'L2', '[INFO]');
		# temporary disabling masking
		commandSystemdModule('disable', 'packagekit');
		#commandSystemdModule('mask --now', 'packagekit');
		if (getSystemdState('packagekit') eq 'active') {
			$packagekitState = 'active';
			return (0);
		} else {
			$packagekitState = 'inactive';
			return (1);
		}
	} else {
		$packagekitState = 'inactive';
		printLog("packagekit is already inactive", 'L2', '[INFO]');
		return (1);
	}
}




###############################################################################
# sets the systemd module to active and unmasks it
# returns 1 if successful, 0 if not
#
sub activatePackagekit {
	if (getSystemdState('packagekit') eq 'inactive') {
		printLog("packagekit is inactive => activating ...", 'L2', '[INFO]');
		commandSystemdModule('unmask', 'packagekit');
		if (getSystemdState('packagekit') eq 'active') {
			$packagekitState = 'active';
			return (1);
		} else {
			$packagekitState = 'active';
			return (0);
		}
	} else {
		$packagekitState = 'active';
		printLog("packagekit is already active", 'L2', '[INFO]');
		return (1);
	}
}




###############################################################################
# creates a file if the content isn't already the same
# it removes the file if the module gets removed
# createFileModule( $module, $action, $filePath, $content, $executable );
# createFileModule( $module, $action, $filePath, $content );
#
sub createFileModule {
	my ($module, $action, $filePath, $content, $executable) = @_;
	$executable //= 0;

	if ($action eq 'install' || $action eq 'upgrade') {
		
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		my $success = createFile($filePath, $content, $executable);

		if (1 == $success){
			printLog("$filePath for $origConfModules{$module}{name} was created", 'L1', '[INFO]');

			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			
			addToConfiguredModules($module, "success");

			if ("yes" eq $origConfModules{$module}{restart}) {
				setRestartValues($module);
			}
		} elsif (0 == $success){
			printLog("$origConfModules{$module}{name} was already created with correct content", 'L1', '[INFO]');
			
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";

			addToConfiguredModules($module, "nothingToDo");
			addToConfiguredModules($module, "success");
		} else {
			printLog("$filePath for $origConfModules{$module}{name} failed to be created", 'L1', '[ERROR]');
			
			$origConfModules{$module}{installed} = "failed";
			
			addToConfiguredModules($module, "failed");
		}
	}
	
	if ($action eq 'remove') {
		unlink($filePath);
		if (-e $filePath) {
			printLog("$filePath for $origConfModules{$module}{name} failed to be removed", 'L1', '[ERROR]');
			
			$origConfModules{$module}{installed} = "remove failed";
			$origConfModules{$module}{version} = $localConfModules{$module}{version};
			$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
			
			addToConfiguredModules($module, "remove failed");
		} else {
			printLog("$filePath for $origConfModules{$module}{name} was removed", 'L1', '[INFO]');
			
			$origConfModules{$module}{installed} = 'no';
			$origConfModules{$module}{upgraded} = 'yes';
			
			addToConfiguredModules($module, 'removed');

			if ("yes" eq $origConfModules{$module}{restart}) {
				setRestartValues($module);
			}
		}
	}
}




###############################################################################
# Creates a udev configuration to use specific LTE modules
#
sub LTEModuleFix {
	my ($module, $action, $name, $vendor, $product, $bConfigurationValue) = @_;
	my $retval1;
	my $retval2;
	my $fileName1 = "/etc/modprobe.d/$name.conf";
	my $fileName2 = "/etc/udev/rules.d/77-mm-$name.rules";
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"options usbserial vendor=0x$vendor product=0x$product\n";
	my $fileText2 = "# added by tuxedo-tomte, any changes might be overwritten by Tomte as needed!! ".$niceTime."\n".
		"ACTION==\"add|change\", SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"$vendor\", ATTR{idProduct}==\"$product\", ATTR{bNumConfigurations}==\"3\", ATTR{bConfigurationValue}!=\"$bConfigurationValue\" ATTR{bConfigurationValue}=\"$bConfigurationValue\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval1 = write_file($fileName1, {'err_mode' => 'carp'}, $fileText1);
		$retval2 = write_file($fileName2, {'err_mode' => 'carp'}, $fileText2);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retval1 = write_file($fileName1, {'err_mode' => 'carp'}, $fileText1);
		$retval2 = write_file($fileName2, {'err_mode' => 'carp'}, $fileText2);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			setRestartValues($module);
		}
	}
	if ($action eq 'remove') {
		unlink($fileName1);
		unlink($fileName2);

		$origConfModules{$module}{installed} = 'no';
		$origConfModules{$module}{upgraded} = 'yes';
		addToConfiguredModules($module, 'removed');
	}
}


###############################################################################
# creates a file if the content isn't already the same
# createFile( $filePath, $content, $executable );
# createFile( $filePath, $content );
#
# $executable has to be 1|"yes"|"+x" to be executable
#
# returns 
#        1 if the content was changed successfully
#        0 if the content was already correct
#       -1 if there was an error writing to the file
sub createFile {
    my ($filePath, $content, $executable) = @_;
    $executable //= 0;  # Set default value if $executable is not provided

	if (-e $filePath) {
		# Read the current content of the file
		my $currentContent = read_file($filePath, {'err_mode' => 'carp'});

		my $fileIsExecutableCheck = 1;
		if(1 eq $executable || "yes" eq $executable || "+x" eq $executable){
			$fileIsExecutableCheck = -x $filePath;
		}

		# Check if the current content is the same as the provided content
		if ($currentContent eq $content && $fileIsExecutableCheck) {
			return 0;  # Return 0 if the content is already correct
		}
	}

    # Write the new content to the file
    if(! write_file($filePath, {'err_mode' => 'carp'}, $content)) {
        return -1;  # Return -1 if there was an error writing to the file
    }

    # If the file is supposed to be executable, set the execution permission
    if(1 eq $executable || "yes" eq $executable || "+x" eq $executable){
        if(system("chmod +x $filePath")) {
            return -1;  # Return -1 if there was an error setting the execution permission
        }
    }

    # Read the current content of the file again
    my $currentContent = read_file($filePath, {'err_mode' => 'carp'});

	my $fileIsExecutableCheck = 1;
	if(1 eq $executable || "yes" eq $executable || "+x" eq $executable){
		$fileIsExecutableCheck = -x $filePath;
	}
	
    # Check if the content of the file is not the same as the provided content
    if ($currentContent ne $content || ! $fileIsExecutableCheck) {
        return -1;  # Return -1 if the content is not correctly written to the file
    }

    return 1;  # Return 1 if the content was changed successfully
}



###############################################################################
# add's, upgrades or deletes entries into the grub file /etc/default/grub
# grubModuleEdit( module, silent, install|upgrade|remove, kernelParameter|... );
# where $silent = 0 means normal operation and
# $silent = 1 means that it will not activate addToConfiguredModules
#
sub grubModuleEdit {
	my ($module, $action, $silent, @kernelParameters) = @_;
	my $retVal;
	if ($LiveISO) {
		printLog("not changing grub for $module as this is a LiveISO", 'L0', '[INFO]');
		return (0);
	}
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}", 'L1', '[INFO]');
		printLog("kernelparameters to insert: @kernelParameters", 'L2', '[DEBUG]');
		$retVal = insertGrub($module, \@kernelParameters);
		printLog("retVal: $retVal", 'L2', '[DEBUG]');
		if ($retVal < 0) {
			$origConfModules{$module}{installed} = "failed";
			unless ($silent) {
				addToConfiguredModules($module, "failed");
			}
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retVal > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				unless ($silent) {
					addToConfiguredModules($module, "success");
				}
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
				unless ($silent) {
					addToConfiguredModules($module, "nothingToDo");
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}", 'L1', '[INFO]');
		$retVal = insertGrub($module, \@kernelParameters);
		if ($retVal < 0) {
			$origConfModules{$module}{installed} = "failed";
			unless ($silent) {
				addToConfiguredModules($module, "failed");
			}
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retVal > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				unless ($silent) {
					addToConfiguredModules($module, "success");
				}
			} else {
				printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
				unless ($silent) {
					addToConfiguredModules($module, "nothingToDo");
				}
			}
		}
	}
	if ($action eq 'remove') {
		if (removeWarningMessage("$origConfModules{$module}{name}\n")) {
			removeKernelParameters($module, $silent, @kernelParameters);
		}
	}
}





###############################################################################
# add's, upgrades or deletes debian packages
# debianPackageModule( module, install|upgrade|remove );
# returns 1 if successfull
# returns 0 if not succesfull
#
sub debianPackageModule {
	my ($module, $action) = @_;
	my $success = 0;

	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();

			# if it is a DKMS package, check if it should be installed in FAI
			# or LiveISO and set the verbose line
			setDkmsVerbose( $module, 1 );

			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = 'yes';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, 'success');
				if ($origConfModules{$module}{restart} eq 'yes') {
					setRestartValues($module);
				}
				$success = 1;
			} else {
				$origConfModules{$module}{installed} = 'failed';
				addToConfiguredModules($module, 'failed');
				$success = 0;
			}

			# remove verbose line if it was set above
			setDkmsVerbose( $module, 0 );

		} else {
			printLog("$origConfModules{$module}{name} was already installed", 'L1', '[INFO]');
			addToConfiguredModules($module, 'nothingToDo');
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
			$success = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages", '[INFO]');
		$success = 0;
	}
	if ($action eq 'remove') {
		if (removeWarningMessage("$origConfModules{$module}{name}\n")) {
			$success = removeDebianModule($module, 1, '');
		}
	}
	return $success;
}





###############################################################################
# adds/removes 'verbose="1"' in /etc/dkms/framework.conf
# accepts setDkmsVerbose( 0|1 )
#
sub setDkmsVerbose {
	my ( $module, $value ) = @_;
	my $dkmsFile = '/etc/dkms/framework.conf';
	my $result;
	my $output;
	if ($value == 1) {
		if (($origConfModules{$module}{dkms} eq 'yes') && (($FAI && ($origConfModules{$module}{FAI} eq 'yes')) || ($LiveISO && ($origConfModules{$module}{LiveISO} eq 'yes')))) {
			unless (isLineInFile( $dkmsFile, 'verbose="1"' )) {
				$result = append_file( $dkmsFile, {'err_mode' => 'carp'}, "verbose=\"1\"\n");
				printLog("append verbose into dkms file for $module", 'L2', '[INFO]');
				return ($result);
			} else {
				printLog("line verbose is already in $dkmsFile", 'L2', '[INFO]');
				return (1);
			}
		}
	} elsif ($value == 0) {
		if (($origConfModules{$module}{dkms} eq 'yes') && (($FAI && ($origConfModules{$module}{FAI} eq 'yes')) || ($LiveISO && ($origConfModules{$module}{LiveISO} eq 'yes')))) {
			printLog("substitute 'verbose' in dkms file $dkmsFile for $module", 'L2', '[INFO]');
			$result = edit_file { s/verbose="1"//g } $dkmsFile, {'err_mode' => 'carp'};
			if ($result >= 0) {
				printLog("verbose DKMS substitution successful", 'L2', '[INFO]');
				return (1);
			}
		}
	}
	return (0);
}





###############################################################################
# Deinstalls all packages beginning with a given string except the one given as
# second parameter
# returns 0 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 1 if everything was ok, even if no packages were found
#
# !!!!! WARNING !!!! this is mostly adapted to the nvidia installation module
#
sub deinstExcept {
	my $deinst = shift;
	my $except = shift;
	my $retValue = '';
	my $searchCmd = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' $deinst*"." 2>&1";
	printLog("search command: $searchCmd", 'L2', '[DEBUG]');
	my $retString = `$searchCmd`;
	$retValue = $?/256;
	printLog("first result for $deinst:\n$retString", 'L2', '[DEBUG]');
	my $deinstCmd;
	my $deinstKey;
	my $deinstList ='';
	if ($retValue != 0) {
		if ($retValue == 1) {
			printLog("no packages found matching search string to deinstall packages: $deinst with except pattern: $except", 'L1', '[DEBUG]');
			return (1);
		}
		printLog('something went wrong while searching for packages', 'L1', '[WARN]');
		return (0);
	}
	my %retHash = $retString =~ /(\S+)\s*(\S+)/g;
	my @exceptDependencies = getPackageDependencies($except);

	$deinstCmd = $consoleLanguage.'apt-get -yq remove -o Dpkg::lock::timeout=0';
	my $deinstCounter = 0;

	foreach $deinstKey (keys %retHash) {
		printLog("deinstKey: $deinstKey except: $except retHash: $retHash{$deinstKey}", 'L2', '[DEBUG]');
		# usefull for debug
		if (grep( /^$deinstKey$/, @exceptDependencies)) {
			printLog("grep: $deinstKey found in dependencies, do NOT delete!", 'L2', '[DEBUG]');
		} else {
			printLog("grep: $deinstKey not found in dependencies, delete!", 'L2', '[DEBUG]');
		}
		# check if it is installed/not exempt/not a dependency of the exemp
		if (($retHash{$deinstKey} =~ /i./) &&
			!($deinstKey =~ $except) &&
			!(grep( /^$deinstKey$/, @exceptDependencies ))) {
			$deinstCounter++;
			$deinstCmd .= ' '.$deinstKey;
			$deinstList .= ' '.$deinstKey;
		}
	}
	if ($deinstCounter != 0) {
		printLog("deinstCounter not 0, deinstalling: $deinstList", 'L0', '[DEBUG]');
		my $retText = '';
		if ($FAI) {
			printLog("command to deinstall: $deinstCmd", 'L2', '[DEBUG]');
			$retText = `$deinstCmd`;
		} else {
			$deinstCmd .= ' >/dev/null 2>&1';
			printLog("command to deinstall: $deinstCmd", 'L2', '[DEBUG]');
			if (unlockPM("$deinstCmd") && (isPMlocked() == 0)) {
				printLog("deinstalling: $deinstList", 'L2', '[DEBUG]');
				$retText = `$deinstCmd`;
				lockPM();
			}
		}
		$retValue = '';
		$retValue = $?/256;
		if ($retValue != 0) {
			printLog("failed to deinstall packages, retvalue: >$retValue<", 'L0', '[WARN]');
			printLog("retText: $retText", 'L0', '[WARN]');
			return (0);
		} else {
			printLog('deinstallation of packages successful', 'L1', '[INFO]');
			return (1);
		}
	} else {
		printLog('nothing to deinstall', 'L1', '[INFO]');
		return (1);
	}
}




###############################################################################
# Finds all dependencies for a given package and returns them in an array
#
sub getPackageDependencies {
	my $package = shift;
	my $result;
	my @lines;
	my $line;
	my $pkgString;
	my @packages;
	my $searchCmd = $consoleLanguage.'apt-cache depends --important '.$package;
	$result = `$searchCmd`;
	@lines = split /\n/, $result;
	foreach $line (@lines) {
		if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
			$pkgString = $1;
			printLog("found dependency: $pkgString", 'L2', '[DEBUG]');
			push @packages, $pkgString;
		}
	}
	return @packages;
}




###############################################################################
# Checks if the package is in any of the repositories
#
sub isPackageInRepo {
	my $package = shift;
	my $returnFromSearch = `apt-cache search --names-only ^$package\$`;
	chop($returnFromSearch);
	$returnFromSearch =~ s/ .*//;
	printLog("package: >$package< returnFromSearch: >$returnFromSearch<", '2', '[DEBUG]');
	if ($package eq $returnFromSearch) {
		printLog("package $package found in repos", 'L2', '[DEBUG]');
		return (1);
	} else {
		printLog("package $package can't be found in the repositories", 'L2', '[ERROR]');
		return (0);
	}
}





###############################################################################
# Deinstalls a package
# returns 1 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 0 if everything was ok, even if no package were found
#
sub deinstallSinglePackage {
	my $deinst = shift;
	my $aptgetDeinst = 'apt-get -yq remove -o Dpkg::lock::timeout=0';
	my $retValue;

	$aptgetDeinst .= " $deinst";
	printLog("deinstalling: $deinst", 'L0', '[INFO]');
	$aptgetDeinst .= " >/dev/null 2>&1";
	if (isPackageInstalled($deinst)) {
		deactivatePackagekit();
		if (unlockPM("$aptgetDeinst") && (isPMlocked() == 0)) {
			printLog("executing deinstallation", 'L2', '[DEBUG]');
			if (system($aptgetDeinst)) {
				$retValue = $?/256;
				lockPM();
				printLog("failed to deinstall package, retvalue: $retValue", 'L0', '[WARN]');
				return (1);
			} else {
				printLog('deinstallation of package successful', 'L0', '[INFO]');
				return (0);
			}
		} else {
			printLog("package deinstallation failed!! Could not get package manager lock", 'L2', '[WARN]');
			return (0);
		}
	} else {
		printLog("package $deinst was not found", 'L0', '[WARN]');
	}
}





###############################################################################
# Checks if the package is installed on the system
# return 1 if yes
# return 0 if no
#
sub isPackageInstalled {
	my $package = shift;
	my $cmd = $consoleLanguage.'dpkg-query -W -f=\'${db:Status-Abbrev}\' '.$package.' 2>&1';
	my $retString = `$cmd`;
	my $retValue = $?/256;
	printLog("checking if $package is installed\nanswer: $retString", 'L2', '[DEBUG]');
	if ($retString =~ m/^[ih][i]\s$/) {
		printLog("package $package is installed: $retString", 'L1', '[DEBUG]');
		return (1);
	} else {
		printLog("package $package is not installed: $retString", 'L1', '[DEBUG]');
		return (0);
	}
}




###############################################################################
# checks if packages given by an array are installed
# @notInstalledPackages = arePackagesInstalled( @packages )
# returns all packages that are not installed
#
sub arePackagesInstalled {
	my @packages = @_;
	my $queryHead = $consoleLanguage."dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\\n\'";
	my $queryTail = " 2>&1";
	my $packageQuery = $queryHead;
	my $package;
	my $line;
	my @lines;
	my $retLines;
	my $retValue;
	my @packagesNotInstalled;

	if (scalar(@packages) == 0) {
		return ('');
	}
	foreach $package (@packages) {
		$packageQuery .= " $package";
	}

	$packageQuery .= $queryTail;
	$retLines = `$packageQuery`;
	$retValue = $?/256;
	printLog("are packages installed retLines: $retLines retValue $retValue", 'L2', '[DEBUG]');
	@lines = split /\n/, $retLines;
	foreach $line (@lines) {
		# find packages that are not installed
		if ($line =~ /dpkg-query:/) {
			$line =~ /.*matching\s(\S+)/;
			setPackageInstallStatus( $1, 'not installed' );
			push( @packagesNotInstalled, $1 );
		# find not completely installed or removed packages
		} else {
			$line =~ /(\S+)\s*(\S+)/;
			setPackageInstallStatus( $1, $2 );
			# only insert packages to be installed to array
			if ($2 =~ /[uihrp][ncHUFWt]/) {
				push( @packagesNotInstalled, $1 );
			}
		}
	}
	return ( @packagesNotInstalled );
}




###############################################################################
# returns the package version string or '0' if the return value from
# dpkg-query was an empty string
#
sub getPackageVersion {
	my $package = shift;
	my $cmd = $consoleLanguage.'dpkg-query --showformat=\'${Version}\' --show '.$package.' 2>&1';
	my $retString = '';
	$retString = `$cmd`;
	my $retValue = $?/256;
	printLog("version string for $package: $retString retValue: $retValue", 'L2', '[DEBUG]');
	if ($retValue == 0) {
		$retString =~ s/.*://;
		if ($retString ne '') {
			printLog("package $package has version: $retString", 'L1', '[DEBUG]');
			return $retString;
		} else {
			printLog("package $package is probably not installed, can't get its version number", 'L1', '[WARN]');
			return '';
		}
	} else {
		printLog("package $package is probably not installed, can't get its version number", 'L1', '[WARN]');
		return '';
	}
}




###############################################################################
# installs a package by apt-get
# returns 1 if successful
# returns 0 if package was not installed
#
sub installPackage {
	my $packageName = shift;
	my $retval;
	if (isPackageInstalled($packageName)) {
		return (1);
	}
	if ($FAI) {
		printLog("install package $packageName", 'TL0', '[INFO]');
		# usefull debug option: Debug::pkgDPkgProgressReporting=true
		if ($logLevel > 1) {
			$retval = `apt-get -o Debug::pkgDPkgProgressReporting=true -o Dpkg::lock::timeout=0 -y install $packageName`;
		} else {
			$retval = `apt-get -y install -o Dpkg::lock::timeout=0 $packageName`;
		}
		printLog("return from apt-get:\n$retval", 'TL2', '[DEBUG]');
		$retval = isPackageInstalled($packageName);
	} elsif (!($LiveISO && $noNetwork)) {
		messageLongInstall();
		printLog("install package $packageName", 'L0', '[INFO]');
		if (checkNetwork(10, 1)) {
			deactivatePackagekit();
			if (unlockPM("apt-get -yq install $packageName") && (isPMlocked() == 0)) {
				printLog("installing $packageName", 'L2', '[DEBUG]');
				if ($logLevel > 1) {
					$retval = `apt-get -yq -o Dpkg::lock::timeout=0 install $packageName >>$logFile 2>&1`;
				} else {
					$retval = `apt-get -yq -o Dpkg::lock::timeout=0 install $packageName >/dev/null 2>&1`;
				}
				lockPM();
				printLog("return from apt-get:\n$retval", 'L2', '[DEBUG]');
				$retval = isPackageInstalled($packageName);
				if ($retval == 0) {
					printLog("failed to install $packageName", 'L0', '[WARN]');
					printLog("will try again later", 'L0', '[WARN]');
					# repair a possibly wrecked package manager
					if (unlockPM('dpkg --configure -a') && (isPMlocked() == 0)) {
						printLog("executing --configure -a", 'L2', '[DEBUG]');
						`dpkg --configure -a`;
						lockPM();
						startTomteDelayed();
					} else {
						printLog('Could not repair package management, will try again later', 'L0', '[WARN]');
						startTomteDelayed();
					}
				}
			} else {
				printLog("failed to get package management lock to install $packageName!!", 'L2', '[WARN]');
				startTomteDelayed();
				return (0);
			}
		} else {
			printLog("no network connection found, can't install packages!!", 'TL0', '[WARN]');
			startTomteDelayed();
		}
	} else {
		printLog("not installing package $packageName because no network detected", 'L0', '[WARN]');
		startTomteDelayed();
	}
	return $retval;
}




###############################################################################
# fills the hash value with all the available packages
#
sub initAvailablePackagesList {
	@availableDebianPackages = `apt-cache pkgnames`;
	chomp(@availableDebianPackages);
}




###############################################################################
# isPackageAvailable( $package ) where package might be a regular expression !!
#
sub isPackageAvailable {
	my $package = shift;
	if ( grep( /^$package$/, @availableDebianPackages ) ) {
		return (1);
	}
	return (0);
}



###############################################################################
# setPackageInstallStatus( package, status )
# sets the installation status of a package and writes it into the hash
#
sub setPackageInstallStatus {
	my ($package, $status) = @_;
	$packageHash{$package} = $status;
}




###############################################################################
# removes a package by apt-get
# parameters are parameters for apt-get
# removePackage( packagename, parameters )
# returns 1 if successful or not installed
# returns 0 if failed
#
sub removePackage {
	my ($packageName, $parameter) = @_;
	my $retval;
	printLog("remove package $packageName", 'TL0', '[INFO]');
	deactivatePackagekit();
	if (!defined($parameter)) {
		printLog("parameter was undefined", 'L2', '[WARN]');
		$parameter = '';
	}
	if (unlockPM("apt-get -yq remove $parameter $packageName") && (isPMlocked() == 0)) {
		printLog("removing $packageName", 'L2', '[DEBUG]');
		$retval = `$consoleLanguage apt-get -yq -o Dpkg::lock::timeout=0 remove $parameter $packageName >/dev/null 2>&1`;
		lockPM();
		printLog("return from apt-get:\n$retval", 'L2', '[DEBUG]');
		$retval = isPackageInstalled($packageName);
		if ($retval == 1) {
			printLog("failed to remove $packageName", 'L0', '[WARN]');
			printLog("will try again later", 'L0', '[INFO]');
			startTomteDelayed();
			return (0);
		}
	} else {
		printLog("locks for package management could not be unlocked!!", 'L2', '[WARN]');
		startTomteDelayed();
		return (0);
	}
	return (1);
}




###############################################################################
# sets mark to auto or manual
# usage setAptMark('package_name','auto|manual')
# returns 1 if set
# returns 0 if not
#
sub setAptMark {
	my ($package, $mark) = @_;
	my $exitStatus;
	my $retString;
	my $aptMark = getAptMark($package);
	if ( $aptMark && ($mark eq 'manual') ) {
		printLog("package $package is set to \"auto\", changing to \"manual\" now", 'L1', '[INFO]');
		$retString = `$consoleLanguage apt-mark manual $package`;
		$exitStatus = $?;
		printLog("result: $retString exitStatus: $exitStatus", 'L2', '[INFO]');
		if (($retString =~ /set to manually installed/) && ($exitStatus == 0)) {
			printLog("return value confirmed set to manually installed", 'L2', '[DEBUG]');
			return (1);
		} else {
			printLog("desired mark: not set !!!", 'L2', '[ERROR]');
			return (0);
		}
	} elsif ( !$aptMark && ($mark eq 'auto') ) {
		printLog("package $package is set to \"manual\", changing to \"auto\" now", 'L1', '[INFO]');
		$retString = `$consoleLanguage apt-mark auto $package`;
		$exitStatus = $?;
		printLog("result: $retString exitStatus: $exitStatus", 'L2', '[INFO]');
		if (($retString =~ /set to automatically installed/) && ($exitStatus == 0)) {
			printLog("return value confirmed set to automatically installed", 'L2', '[DEBUG]');
			return (1);
		} else {
			printLog("desired mark: not set !!!", 'L2', '[ERROR]');
			return (0);
		}
	}
}




###############################################################################
# gets apt-mark auto or manual
# returns 1 if auto
# returns 0 if manual or package does not exist
#
sub getAptMark {
	my $package = shift;
	my $retVal;
	$retVal = `$consoleLanguage apt-mark showauto $package`;
	if ( $retVal =~ /$package/mg ) {
		printLog("package: $package mark is auto", 'L2', '[DEBUG]');
		return (1);
	} else {
		printLog("package: $package mark is manual", 'L2', '[DEBUG]');
		return (0);
	}
}



###############################################################################
# installs a linux kernel from the name of the main metapackage
# installKernelFlavour('metapackageName', \$failed, \$somethingDone)
# reqires two parameters failed and nothingDone
# returns 0 if something went wrong
# returns 1 if subroutine run through
#
sub installKernelFlavour {
	my ($flavour, $failed, $somethingDone) = @_;
	if (!(defined ${$failed})) {
		${$failed} = 0;
	}
	if (!(defined ${$somethingDone})) {
		${$somethingDone} = 0;
	}
	my $partialName;
	my $installCmd = 'apt-get install -yq -o Dpkg::lock::timeout=0';
	my $testCmd = "dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\'";
	my $testCmd2 = $testCmd;
	my $retString;
	my $package;
	my $allPackagesInstalled = 1;
	my @lines;
	my $line;
	my $packageMissing = 0;
	my $exitStatus = 1;
	if (!(exists $flavours{$ubuntuCodename}{$flavour})) {
		printLog("flavour $flavour does not exist!!", 'TL0', '[FATAL]');
		${$failed} += 1;
		return (0);
	}
	if (!populateFlavourPackages("$flavour")) {
		printLog("no packages found for kernel $flavour while installing, this is not good", 'L0', '[ERROR]');
		${$failed} += 1;
		return (0);
	}
	$testCmd = $testCmd.' '.join($", @{ $flavours{$ubuntuCodename}{$flavour}{'packages'}});

	foreach $package (@{ $flavours{$ubuntuCodename}{$flavour}{'packages'}}) {
		$testCmd2 = $testCmd2.' '.$package;
	}
	$testCmd2 = $testCmd2.' 2>&1';
	printLog("testcommand:\n$testCmd2", 'L2', '[DEBUG]');
	$retString = `$testCmd2`;
	printLog("result:\n$retString", 'L2', '[DEBUG]');
	@lines = split /\n/, $retString;
	foreach $line (@lines) {
		$package = $line;
		unless ($package =~ /linux-image-unsigned-.*/) {
			if ($line =~ /dpkg-query: /) {
				$package =~ s/.*\s//;
				printLog("package missing: $package", 'L2', '[ERROR]');
				$packageMissing = 1;
				$installCmd .= ' '.$package;
			}

			# set apt-mark
			if ($line =~ /.*\s[uihrp][ncHUFWti]/) {
				$package =~ s/\s.*//;
				printLog("after regEx package: >$package<", 'L2', '[DEBUG]');
				unless ($line =~ /.*\s[ih][i]/) {
					printLog("package missing: >$package<", 'L2', '[ERROR]');
					$packageMissing = 1;
					$installCmd .= ' '.$package;
				} else {
					printLog("package: >$package<", 'L2', '[DEBUG]');
					unless ( exists $flavours{$ubuntuCodename}{$package}) {
						setAptMark($package, 'auto');
					}
				}
			}
		}
	}

	if ($packageMissing) {
		# install the meta packages as well in case there is a new version
		$installCmd .= " $flavours{$ubuntuCodename}{$flavour}";
		$installCmd .= ' 2>&1';
		messageLongInstall();
		printLog("installing $flavour", 'TL0', '[INFO]');
		deactivatePackagekit();
		if (unlockPM('apt-get update -q and dpkg --configure -a') && (isPMlocked() == 0)) {
			printLog("execute update -q", 'L2', '[DEBUG]');
			`apt-get update -q`;
			printLog("installation command: $installCmd", 'L2', '[DEBUG]');
			$retString = `$installCmd`;
			printLog("retString: $retString", 'L2', '[DEBUG]');
			if ($retString =~ /dpkg --configure -a/) {
				lockPM();
				printLog("some packages are not configured", 'L2', '[DEBUG]');
				printLog("executing: make configure -a", 'L2', '[INFO]');
				if (unlockPM('dpkg --configure -a') && (isPMlocked() == 0)) {
					$exitStatus = 1;
					printLog("executing --configure -a", 'L2', '[DEBUG]');
					`dpkg --configure -a`;
					$exitStatus = $?/256;
					lockPM();
					if ($exitStatus != 0) {
						printLog("configure -a failed!! exiting", 'L0', '[ERROR]');
						${$failed} += 1;
						return (0);
					} else {
						if (unlockPM("$installCmd.$flavours{$ubuntuCodename}{$flavour}") && (isPMlocked() == 0)) {
							$exitStatus = 1;
							printLog("executing Kernel installation", 'L2', '[DEBUG]');
							$retString = `$installCmd`;
							$exitStatus = $?/256;
							lockPM();
						} else {
							printLog("repeated installation failed!!", 'L2', '[ERROR]');
						}
					}
				} else {
					printLog("can't repair package management, can't get locks", 'L2', '[ERROR]');
				}
				if ($exitStatus != 0) {
					printLog("something went wrong while installing kernel packages", 'TL0', '[ERROR]');
					printLog("error: $exitStatus", 'L0', '[ERROR]');
					printLog("$retString", 'L0', '[ERROR]');
				}
			}
		} else {
			printLog("failed get locks to update and configure package management", 'L2', '[ERROR]');
		}
	
		$retString = `$testCmd`;
		printLog("check installed packages: \n$retString", 'L2', '[DEBUG]');
		@lines = split /\n/, $retString;
		$line = '';
		foreach $line (@lines) {
			($package) = $line =~ /^([A-Za-z0-9_\-\.]+)/;
			unless ($package =~ /linux-image-unsigned-.*/) {
				if ($line =~ /dpkg-query: /) {
					$line =~ s/.*\s//;
					printLog("package missing: $package", 'L2', '[WARN]');
					$allPackagesInstalled = 0;
				}
				if ($line =~ /.*\s[uihrp][ncHUFWti]/) {
					if ($line =~ /.*\s[ih][i]/) {
						$line =~ s/\s.*//;
						unless (grep( /^$package$/, @{ $flavours{$ubuntuCodename}{$flavour}{'packages'}})) {
							setAptMark($package, 'auto');
						}
						printLog("$package is installed", 'L2', '[DEBUG]');
						${$somethingDone} += 1;
					} else {
						printLog("failed: $package", 'L2', '[ERROR]');
						$allPackagesInstalled = 0;
					}
				}
			}
		}
		if ($allPackagesInstalled) {
			printLog("kernel $flavour was installed correctly", 'L0', '[DEBUG]');
		}
	} else {
		$installCmd = 'apt-get -o Dpkg::lock::timeout=0 install -yq';
		$installCmd .= " $flavour";
		$installCmd .= ' 2>&1';
		printLog("install kernel metapackage", 'L2', '[INFO]');
		printLog("install command: $installCmd", 'L2', '[DEBUG]');
		if (unlockPM("$installCmd") && (isPMlocked() == 0)) {
			printLog("executing installation", 'L2', '[DEBUG]');
			$retString = `$installCmd`;
			$exitStatus = $?/256;
			lockPM();
			printLog("return from install:\n$retString", 'L2', '[DEBUG]');
			if ($exitStatus != 0) {
				printLog("installation of kernel meta package failed !!!", 'L0', '[ERROR]');
				${$failed} += 1;
			}
		}
	}

	if (!$allPackagesInstalled) {
		${$failed} += 1;
	}
	printLog("failed: ${$failed}, somethingdone: ${$somethingDone}", 'L2', '[ERROR]');
	return (1);
}




###############################################################################
# finds which main packages belong to the flavour and puts them into a list
# works only if packages are known or installed on the system
# returns 0 if something went wrong
# returns 1 if all is good
#
sub populateFlavourPackages {
	my $flavour = shift;
	my @packages;
	my $packageLine;
	my $searchCmd;
	my $result;
	my @lines;
	my $line;
	my $pkgString;
	printLog("populating $flavour", 'L2', '[DEBUG]');
	$searchCmd = $consoleLanguage.'apt-cache depends --important '.$flavours{$ubuntuCodename}{$flavour};
	@packages = split(' ', $flavours{$ubuntuCodename}{$flavour});
	printLog("first searchcommand: $searchCmd", 'L2', '[DEBUG]');
	$result = `$searchCmd`;
	printLog("first result:\n$result", 'L2', '[DEBUG]');
	@lines = split /\n/, $result;
	foreach $line (@lines) {
		if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
			$pkgString = $1;
			if (($pkgString =~ /^linux-.*(?:image|headers|modules)-.*/) && (!($pkgString =~ /unsigned/))) {
				printLog("Accepted: $pkgString", 'L2', '[DEBUG]');
				$packageLine .= " $pkgString";
				push @packages, $pkgString;
			}
		}
	}
	if (@packages) {
		$searchCmd = $consoleLanguage.'apt-cache depends --important '.$packageLine;
		printLog("second searchcommand: $searchCmd", 'L2', '[DEBUG]');
		$result = `$searchCmd`;
		printLog("second result:\n$result", 'L2', '[DEBUG]');
		@lines = split /\n/, $result;
		foreach $line (@lines) {
			if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
				$pkgString = $1;
				if (($pkgString =~ /^linux-.*(?:image|headers|modules)-.*/) && (!($pkgString =~ /unsigned/))) {
					printLog("Accepted: $pkgString", 'L2', '[DEBUG]');
					push @packages, $pkgString;
				}
			}
		}
		@{ $flavours{$ubuntuCodename}{$flavour}{'packages'}} = uniqInArray(@packages);
		printLog("packages found: @{ $flavours{$ubuntuCodename}{$flavour}{'packages'}}", 'L2', '[DEBUG]');
	} else {
		printLog("empty package list for kernel $flavour while populating list, this should not happen!", 'L0', '[DEBUG]');
		return (0);
	}
	return (1);
}



###############################################################################
# receives an array
# returns an array where all values are unique
#
sub uniqInArray {
	my %seen;
	return grep { !$seen{$_}++ } @_;
}




###############################################################################
# accepts a kernel version and returns an array with all dependant packages
# found for linux-image-$version-tuxedo, linux-headres-$version-tuxedo and
# linux-modules-extra-$version-tuxedo
# returns an empty string if nothing was found or the version entry is wrong
sub populateKernelPackages {
	my $version = shift;
	if ($version =~ /\s/) {
		printLog("something is wrong with the kernel version number", 'L0', '[ERROR]');
		return '';
	}
	my @rootPackages = ("linux-headers-$version-tuxedo", "linux-image-$version-tuxedo");
	my @packages;
	my @packagesUnique;
	my $packageLine;
	my $packageString;
	my $searchCommand;
	my $result;
	my $consoleLanguage = 'LANG=C;LANGUAGE=C;';
	my $line;
	my @lines;
	$searchCommand = $consoleLanguage."apt-cache depends --important @rootPackages";
	printLog("first searchcommand: $searchCommand", 'L2', '[DEBUG]');
	$result = `$searchCommand`;
	printLog("first result:\n$result", 'L2', '[DEBUG]');
	@lines = split /\n/, $result;
	foreach $line (@lines) {
		if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
			$packageString = $1;
			if ($packageString =~ /^linux-.*(?:image|headers|modules|unsigned)-.*/) {
				printLog("Accepted: $packageString", 'L2', '[DEBUG]');
				$packageLine .= " $packageString";
				push @packages, $packageString;
			}
		}
	}
	if (@packages) {
		$searchCommand = $consoleLanguage.'apt-cache depends --important --installed '.$packageLine;
		printLog("second searchcommand: $searchCommand", 'L2', '[DEBUG]');
		$result = `$searchCommand`;
		printLog("second result:\n$result", 'L2', '[DEBUG]');
		@lines = split /\n/, $result;
		foreach $line (@lines) {
			if ($line =~ /\s[\s|]Depends:\s[<]?([a-z0-9\-\_\.]+)[>]?/) {
				$packageString = $1;
				if ($packageString =~ /^linux-.*(?:image|headers|modules|unsigned)-.*/) {
					printLog("Accepted: $packageString", 'L2', '[DEBUG]');
					push @packages, $packageString;
				}
			}
		}
	}
	$searchCommand = $consoleLanguage.'dpkg-query -W -f=\'${db:Status-Abbrev}\' '."linux-modules-extra-$version-tuxedo".' 2>&1';
	$result = `$searchCommand`;
	if ($result =~ m/^[uihrp][HUFWti]\s$/) {
		push @packages, "linux-modules-extra-$version-tuxedo";
	}
	push @packages, ("linux-headers-$version-tuxedo", "linux-image-$version-tuxedo");
	@packagesUnique = uniqInArray(@packages);
	printLog("kernel packages found: @packagesUnique", 'L2', '[DEBUG]');

	# safety check: something went wrong if we got more than 20 packages for removal
	if (scalar(@packagesUnique) < 20) {
		return (@packagesUnique);
	} else {
		return '';
	}
}



###############################################################################
# deletes the oldest remnant linux header
# returns 0 if nothing was done
# returns 1 if some linux header was deleted
sub checkAndDeleteOldestRemnantLinuxHeader {
	# Check if the tries file exists
	if (-e $triesFile) {
		printLog("won't delete oldest header because Tomte is running in retry-mode", "L2", '[INFO]');
		return (0);
	}

	my %headers;
	# Get the list of installed linux-tuxedo headers using dpkg-query
	# example: linux-tuxedo-5.15-headers-5.15.0-10033
	my @headersList = split /\n/, qx(dpkg-query -W -f='\${db:Status-Status}=\${Version}=\${Package}\n' 'linux-tuxedo-*-headers-*');

	# Check each header line and store installed headers with their versions
	foreach my $line (@headersList) {
		chomp $line;
		my ($status, $version, $package) = split /=/, $line, 3;
		if (
			# Check if $package is installed
			"installed" eq $status &&

			# Check if $package matches the expected pattern
			$package =~ /^linux-tuxedo-.*-headers-.*$/ &&

			# Check if $package does not contain any whitespace characters
			$package !~ /\s/ &&

			# Check if the length of $package exceeds 50 characters
			length($package) < 50
		
		){
			$headers{$version} = $package;
		}
	}

	my %images;
	# Get the list of installed linux-image packages using dpkg-query
	# example: linux-image-5.15.0-10025-tuxedo
	my @imagesList = split /\n/, qx(dpkg-query -W -f='\${db:Status-Status}=\${Version}=\${Package}\n' 'linux-image-*-tuxedo');

	# Check each images line and store installed headers with their versions
	foreach my $line (@imagesList) {
		chomp $line;
		my ($status, $version, $package) = split /=/, $line, 3;
		if ("installed" eq $status){
			$images{$version} = $package;
		}
	}

	# Get the current kernel version by removing the "-tuxedo" suffix
	my $currentKernelVersion = `uname -r`;
	$currentKernelVersion =~ s/-tuxedo$//;

	my @headersOnly;
	# Get the headers where no corresponding image exists
	foreach my $key (keys %headers) {
		# Skip if there is a corresponding image for the header version
		if (exists $images{$key}) {
			next;
		}

		# Skip if the header version matches the current kernel version
		# header version can be 6.5.0-10005.5 but currentKernelVersion is then just 6.5.0-10005
		if ($key =~ /$currentKernelVersion/) {
			next;
		}

		# Add the header version to the @headersOnly array
		push @headersOnly, $key;
	}

	# If there are headers without corresponding images
	if (@headersOnly) {
		# Sort the headers in ascending order
		@headersOnly = sort { version_compare($a, $b) } @headersOnly;

		# Get the oldest header package name
		my $oldestHeader = $headers{$headersOnly[0]};

		# Safety check: Verify the format and length of $oldestHeader
		if (
			# Check if $oldestHeader does not match the expected pattern
			$oldestHeader !~ /^linux-tuxedo-.*-headers-.*$/ ||

			# Check if $oldestHeader contains any whitespace characters
			$oldestHeader =~ /\s/ ||

			# Check if the length of $oldestHeader exceeds 50 characters
			length($oldestHeader) > 50
			) {
				printLog("Skipping removal of header $oldestHeader due to invalid format or length", "L0", '[WARN]');
				return 0;
		}

		printLog("Removing header $oldestHeader", "L2", '[INFO]');

		# Construct the apt-get purge command to remove the oldest header
		my $purgeCommand = $consoleLanguage."apt-get purge -o Dpkg::lock::timeout=0 --assume-yes $oldestHeader";
		printLog("purge command: $purgeCommand", 'L2', '[DEBUG]');

		# Attempt to unlock the package management and check if it's unlocked
		if (unlockPM("purge command: $purgeCommand") && (isPMlocked() == 0)) {
			# Execute the purge command and capture the result and error
			printLog("executing purge", 'L2', '[DEBUG]');
			my $result = `$purgeCommand`;
			my $error = $?;
			lockPM();
			printLog("result: $result\nerror: $error", 'L2', '[DEBUG]');

			# Log the success message
			printLog("successfully removed old header $oldestHeader", 'L0', '[INFO]');
			return 1;
		} else {
			# Log the failure message if package management is busy
			printLog("could not remove the header $oldestHeader as package management is busy", 'L0', '[WARN]');
		}
	}
	return 0;
}




###############################################################################
# deletes the oldest TUXEDO kernel by version
# returns 0 if nothing was done
# returns 1 if some kernel was deleted
sub checkAndDeleteOldestTuxedoKernel {
	my $DH;
	my %fileListInitrd;
	my %fileListVmlinuz;
	my $fileSize;
	my $version;
	my $file;
	my $purgeCommand;
	my $bootDir = '/boot';

	if (-e $triesFile) {
		printLog("won't delete oldest kernel because Tomte is running in retry-mode", "L2", '[INFO]');
		return (0);
	}

	if (opendir($DH,$bootDir)) {
		while ($file = readdir($DH)) {
			if ($file =~ /initrd\.img-(.*)-tuxedo$/) {
				printLog("found file: $file", 'L2', '[DEBUG]');
				$fileSize = -s "$bootDir/$file";
				printLog("size: $fileSize", 'L2', '[DEBUG]');
				if (($fileSize) > 1000000) {
					printLog("filesize accepted into hash-list", 'L2', '[DEBUG]');
					$fileListInitrd{$1} = $fileSize;
				}
			}
			if ($file =~ /vmlinuz-(.*)-tuxedo/) {
				printLog("found file: $file", 'L2', '[DEBUG]');
				$fileSize = -s "$bootDir/$file";
				printLog("size: $fileSize", 'L2', '[DEBUG]');
				if (($fileSize) > 1000000) {
					printLog("filesize accepted into hash-list", 'L2', '[DEBUG]');
					$fileListVmlinuz{$1} = $fileSize;
				}
			}
		}
	} else {
		printLog("could not open $bootDir", 'L2', '[ERROR]');
		return (0);
	}

	my @fileListResult;
	foreach $version (keys %fileListInitrd) {
		if (exists $fileListVmlinuz{$version}) {
			printLog("matching vmlinuz found with version: $version", 'L2', '[DEBUG]');
			push (@fileListResult, $version);
		}
	}

	printLog("all found versions: @fileListResult", 'L2', '[DEBUG]');

	my $keepKernels = 3;
	if (scalar(@fileListResult) > $keepKernels) {
		printLog("more than $keepKernels kernels found, will delete the oldest one", 'L2', '[INFO]');
		@fileListResult = sort { version_compare($b, $a) } @fileListResult;
		printLog("sorted filelist: @fileListResult", 'L2', '[DEBUG]');
		$version = '';
		$version = $fileListResult[-1];
		my $currentKernelVersion = `uname -r`;
		$currentKernelVersion =~ s/-tuxedo$//;
		if (! ($currentKernelVersion =~ /$version/)) {
			printLog("not current running kernel => trying to delete version: $version", 'L2', '[INFO]');
			# get all related kernel packages
			my @packageList = populateKernelPackages($fileListResult[-1]);
			# purge package
			$purgeCommand = $consoleLanguage."apt-get purge -o Dpkg::lock::timeout=0 --assume-yes @packageList";
			printLog("purge command: $purgeCommand", 'L2', '[DEBUG]');
			my $result;
			my $error;
			if (unlockPM("purge command: $purgeCommand") && (isPMlocked() == 0)) {
				printLog("executing purge", 'L2', '[DEBUG]');
				$result = `$purgeCommand`;
				$error = $?;
				lockPM();
				printLog("result: $result\nerror: $error", 'L2', '[DEBUG]');

				# log success
				printLog("successfully removed old kernel $version", 'L0', '[INFO]');

			} else {
				printLog("could not remove the kernel $version as package management is busy", 'L0', '[WARN]');
			}
		} else {
			printLog("kernel version ($version) to delete is the same as the one currently running => abort", 'L0', '[WARN]');
			return (0);
		}
	} else {
		printLog("less than 4 kernels present => nothing to do", 'L2', '[DEBUG]');
		return (0);
	}
}



###############################################################################
# removes a module containing a debian pakage
# removeDebianModule(module, restart, parameters)
# module is the short modulename
# if restart = 0 => don't restart
# if restart = 1 => restart
# checks if the package is installed
# returns 1 if successfull
# returns 0 if not successfull
#
sub removeDebianModule {
	my ($module, $restart, $parameter) = (@_);
	my $success = 0;
	if (isPackageInstalled($origConfModules{$module}{name})) {
		if (removePackage($origConfModules{$module}{name}, "$parameter")) {
			addToConfiguredModules($module, "removed");
			$origConfModules{$module}{installed} = "no";
			$origConfModules{$module}{upgraded} = "yes";
			$origConfModules{$module}{required} = "no";
			if ($restart) {
				setRestartValues($module);
			}
			$success = 1;
		} else {
			addToConfiguredModules($module, "remove failed");
			$origConfModules{$module}{installed} = "remove failed";
			$origConfModules{$module}{version} = $localConfModules{$module}{version};
			$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
			$success = 0;
		}
	} else {
		printLog("$origConfModules{$module}{name} is not installed, which is the desired result", 'TL0', '[INFO]');
		addToConfiguredModules($module, "nothingToDo");
		$origConfModules{$module}{installed} = "no";
		$origConfModules{$module}{upgraded} = "yes";
		$origConfModules{$module}{required} = "no";
		$success = 1;
	}
	return $success;
}




###############################################################################
# removes kernel parameter from grub
# removeKernelParameters($module, $silent, @kernelParameters)
# where $silent = 0 means normal operation and
# $silent = 1 means that it will not activate addToConfiguredModules
# returns amount of parameters found
# returns 0 if nothing found or changed
#
sub removeKernelParameters {
	my ($module, $silent, @parameters) = @_;
	my $parameter;
	my $GF;
	my @grubLines;
	my $line;
	my $counter = 0;
	if ((-r $grubFile) && (open($GF, '<', $grubFile))) {
		chomp(@grubLines = <$GF>);
		close($GF);
		if ((-w $grubFile) && (open($GF, '>', $grubFile))) {
			foreach $line (@grubLines) {
				if ($line =~ /^GRUB_CMDLINE_LINUX_DEFAULT="/) {
					foreach $parameter (@parameters) {
						printLog("removing kernel parameter: $parameter", 'L2', '[INFO]');
						if ($line =~ /^GRUB_CMDLINE_LINUX_DEFAULT="(|.* )$parameter( .*|)"/) {
							$line =~ s/$parameter//;
							$line =~ s/ +/ /g;
							$line =~ s/=" /="/;
							$line =~ s/ "$/"/;
							++$counter;
						}
					}
				}
				print $GF "$line\n";
			}
			close($GF);
			unless ($silent) {
				addToConfiguredModules($module, "removed");
			}
			$origConfModules{$module}{installed} = "no";
			$origConfModules{$module}{upgraded} = "yes";
			# temp removing for testing
			#$origConfModules{$module}{required} = "no";
			if ($counter > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
			}
			return ($counter);
		} else {
			printLog("could not open and write $grubFile", 'TL0', '[ERROR]');
			unless ($silent) {
				addToConfiguredModules($module, "remove failed");
			}
			$origConfModules{$module}{installed} = "remove failed";
			$origConfModules{$module}{version} = $localConfModules{$module}{version};
			$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
			return (0);
		}
	} else {
		printLog("could not open and read $grubFile", 'TL0', '[ERROR]');
		unless ($silent) {
			addToConfiguredModules($module, "remove failed");
		}
		$origConfModules{$module}{installed} = "remove failed";
		$origConfModules{$module}{version} = $localConfModules{$module}{version};
		$origConfModules{$module}{hwid} = $localConfModules{$module}{hwid};
		return (0);
	}
	return (0);
}




###############################################################################
# setNoNetwork( 0 or 1 )
# sets the network availability variable
# 0 = network
# 1 = no network
#
sub setNoNetwork {
	my $value = shift;
	if ($LiveISO) {
		if ($value == 1) {
			printLog("setting permanently for this session no network available", 'L0', '[INFO]');
			$noNetwork = 1;
		}
	} else {
		$noNetwork = $value;
	}
}



###############################################################################
# refreshes the package manager database
# needs a module name to set the result and the amount of retries it should do
# in case it fails the first time for some reason
# aptgetRefreshModule($module, $retries)
#
sub aptgetRefreshModule {
	my ($aptgetModule, $refreshTries) = @_;
	my $output;
	my $exitStatus = 1;
	my $refreshTriesDone = 0;
	my $refreshWait = 1;
	unless($LiveISO && $noNetwork) {
		if (checkNetwork(15, 1)) {
			deactivatePackagekit();
			while (($exitStatus != 0) && ($refreshTriesDone <= $refreshTries)) {
				my $command = $consoleLanguage.'apt-get update 2>/dev/null';
				if(unlockPM($command) && (isPMlocked() == 0)) {
					printLog("executing apt-get update", 'L2', '[DEBUG]');
					$output = `$command`;
					$exitStatus = $?/256;
					initAvailablePackagesList();
					lockPM();
					if ($exitStatus != 0) {
						printLog('failed: update packages', 'L0', '[ERROR]');
						printLog("output: $output error code: $exitStatus", 'L0', '[ERROR]');
						if ($exitStatus == 7) {
							printLog('possible network problems', 'L0', '[INFO]');
						}
						addToConfiguredModules($aptgetModule, "failed");
						if ($refreshTriesDone <= $refreshTries) {
							printLog("will try to refresh the repos again", 'L2', '[INFO]');
						}
						$refreshTriesDone++;
						sleep($refreshWait);
					} else {
						printLog("success: update packages", 'L1', '[INFO]');
						addToConfiguredModules($aptgetModule, "success");
					}
				} else {
					printLog("failed to get package management lock to update package management for >$aptgetModule<", 'L2', '[WARN]');
					startTomteDelayed();
					return(0);
				}
			}
		} else {
			printLog("no network available, repos could not be updated", 'TL0', '[WARN]');
			addToConfiguredModules($aptgetModule, "failed");
			setNoNetwork(1);
			return (0);
		}
	} else {
		printLog("not refreshing package management DB as no network available", 'L0', '[WARN]');
		setNoNetwork(1);
		return (0);
	}
}



###############################################################################
# backups file with timestamp
# 
sub backupFile {
	my $fileName = shift;
	my $backupFile = $fileName.'_'.getBackupFileTime().'.bak';
	if (copy($fileName, $backupFile)) {
		printLog("created backup for $fileName", 'TL', '[INFO]');
		return (1);
	} else {
		printLog("Err: $!", 'L0', '[ERROR]');
		printLog("can't create backup file for $fileName", 'TL0', '[ERROR]');
		return (0);
	}
}



###############################################################################
# isLineInFile('filename', 'string')
# matches a line with the 'string' as RegEx(!!!) and returns
# 1 if found
# 0 if not found or failed to open file
#
sub isLineInFile {
	my $filename = shift;
	my $match = shift;
	if ( (-e $filename) && open(FH, '<', $filename) ) {
		while( <FH> ) {
			if ( $_ =~ /^$match$/) {
				return (1);
			}
		}
	} else {
		printLog("can't open file $filename", 'L0', '[WARN]');
	}
	return (0);
}



###############################################################################
# isTextInFile('filename', 'string')
# matches a line with the 'string' and returns
# 1 if found
# 0 if not found or failed to open file
#
sub isTextInFile {
	my $filename = shift;
	my $match = shift;
	if ( (-e $filename) && open(FH, '<', $filename) ) {
		while( <FH> ) {
			if ( $_ =~ /$match/) {
				return (1);
			}
		}
	} else {
		printLog("can't open file $filename", 'L0', '[WARN]');
	}
	return (0);
}




###############################################################################
# returns 1 if active interface found
# returns 0 if none found
#
sub networkStatus {
	my $dirHandle;
	my $interfacesDir = '/sys/class/net';
	if ( !opendir ($dirHandle, $interfacesDir)) {
		printLog("unable to open $interfacesDir: $!", 'L0', '[WARN]');
		return (0);
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' && $_ ne 'lo' } readdir($dirHandle);
	if (scalar(@FILES) < 1) { return (0); }
	foreach my $file (@FILES) {
		if (readFirstLineOfFile("$interfacesDir/$file/operstate") eq 'up' ) {
			return (1);
		}
	}
	return (0);
}



###############################################################################
# waitForNetwork('number of tries', 'wait seconds')
# polls for a network interface for status up
# tries 'number of tries' times and waits in between for 'wait seconds' seconds
# returns 1 if network is active
# returns 0 if network not active
#
sub waitForNetwork {
	my $triesNbr = shift;
	my $wait = shift;
	for ( my $i=1; $i<=$triesNbr; $i++ ) {
		if (networkStatus()) { return (1); }
		printLog("waiting for network: $i of $triesNbr", 'TL2', '[INFO]');
		sleep ($wait);
	}
	return (0);
}




###############################################################################
# checkNetwork('number of tries', 'wait seconds')
# returns 1 if found
# returns 0 if not found
#
sub checkNetwork {
	my $triesNbr = shift;
	my $wait = shift;
	if ((! $FAI) && ($noNetwork == 0)) {
		if (waitForNetwork($triesNbr, $wait)) {
			setNoNetwork(0);
			printLog('found network !', 'L1', '[INFO]');
			return (1);
		} else {
			setNoNetwork(1);
			printLog('no network found!! some fixes might not be applied correctly', 'TL0', '[WARN]');
			startTomteDelayed();
			return (0);
		}
	}
	return (0);
}




###############################################################################
# inserts array values as kernel parameters if not present
# example: my $retval = insertGrub(\@kernelParameters);
# returns number of inserted parameters
# return value of -1 means it failed
#
sub insertGrub {
    my $grubFH;
    my @grubLines;
	my $module = shift;
    my $parameters = shift;
    my $parameter;
	my $inserted = 0;

	if ( (-e $grubFile) && open($grubFH, "<", $grubFile) ) {
		while (<$grubFH>) {
	    	push (@grubLines, $_);
		}
		close $grubFH;
    } else {
		printLog("Err: $!", 'L0', '[ERROR]');
		printLog("no $grubFile present or unable to open the file for reading", 'L0', '[ERROR]');
		return (-1);
    }

    foreach( @grubLines ) {
		# find the correct line
		if ( $_ =~ /^GRUB_CMDLINE_LINUX_DEFAULT="/ ) {
			foreach $parameter ( @{$parameters} ) {
				if (insertGrubParameter(\$_, \$parameter)) {
					++$inserted;
				}
			}
		}
    }

	# write the changes into grub config
    if ( open($grubFH, ">", $grubFile) ) {
		print $grubFH @grubLines;
		close ($grubFH);
    } else {
		printLog("Err: $!", 'L0', '[ERROR]');
		printLog("no $grubFile present or unable to open the file for writing", 'L0', '[ERROR]');
		return (-1);
    }
    return $inserted;
}


###############################################################################
# inserts a parameter into a grub line
# the line must begin with: 'GRUB_CMDLINE_LINUX_DEFAULT='
# if the parameter is not present yet
# returns 1 if parameter inserted
# returns 0 if parameter already present
# returns -1 if line is wrong
#
sub insertGrubParameter {
	my ($line, $parameter) = @_;
	my $cleanLine;

	unless ($$line =~ /^GRUB_CMDLINE_LINUX_DEFAULT=/) {
		printLog("grub kernel parameter line is malformed, can't insert $$parameter", 'L0', '[ERROR]');
		return (-1);
	}

	$cleanLine = $$line;
	$cleanLine =~ s/"\R//;
	$cleanLine =~ s/^GRUB_CMDLINE_LINUX_DEFAULT="//;

	if (($cleanLine =~ /^$$parameter /) || ($cleanLine =~ /^$$parameter$/) || ($cleanLine =~ / $$parameter$/) || ($cleanLine =~ / $$parameter /)) {
		printLog("$$parameter is already in grub", 'L2', '[DEBUG]');
		return (0);
	} else {
		$$line =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1 $$parameter"\n/;
		printLog("inserted '$$parameter' into grub line: $$line", 'L1', '[INFO]');
		return (1);
	}
}






###############################################################################
# send message to desktop
# returns 1 if message was sent
# returns 0 if message could not be delivered for any reason
# icon:
# 	dialog-warning
# 	dialog-error
# 	dialog-information
# 	freedesktop.org
# urgency:
# 	0 : Low
# 	1 : Normal
# 	2 : Critical
#
sub messageDesktop {
	my $summary = shift;
	my $body = shift;
	my $urgency = shift;
	my $icon = shift;
	my $retValue = 0;

	my $mUsername = '';
	my $mPid = '';
	my $mLine = '';
	my @whoLines = `who -u`;
	my $environ = '';
	my $dbusAddress;

	# don't message the desktop if LiveISO or FAI
	if ($LiveISO || $FAI) {
		return (0);
	}

	foreach $mLine (@whoLines) {
		if ($mLine =~ /\(:\d+\)/) {
			$mLine =~ /^(\w*).*\s(\d*)\s.*/;
			$mUsername = $1;
			$mPid = $2;
		}
	}
	if (($mUsername eq '') || ($mPid eq '')) {
		printLog('No display for message output found, no username or PID', 'L1', '[INFO]');
		return (0);
	}

	$environ = "/proc/$mPid/environ";
	if ( (-e $environ) && open(FH, "<", $environ) ) {
		$dbusAddress = do { local $/; <FH> };
		close FH;
	} else {
		printLog('No display for message output found', 'L1', '[INFO]');
		return (0);
	}
	
	$dbusAddress =~ /.*?(DBUS_SESSION_BUS_ADDRESS=unix:path=\/run\/user\/\d*\/bus).*/;
	$dbusAddress = $1;
	if ($dbusAddress eq '') {
		printLog('No display for message output found, no DBUS address', 'L1', '[INFO]');
		return (0);
	}

	printLog("messaging desktop", 'L2', '[INFO]');
	my $mCmd = $consoleLanguage."sudo -u $mUsername $dbusAddress gdbus call --session --dest=org.freedesktop.Notifications --object-path=/org/freedesktop/Notifications --method=org.freedesktop.Notifications.Notify \"TUXEDO Tomte\" $sessionID \"$icon\" '$summary' '$body' '[]' '{\"urgency\": <$urgency>, \"desktop-entry\": <\"tuxedo-control-center\">}' 5000";

	`$mCmd`;
	$retValue = $?/256;

	if ($retValue != 0) {
		printLog("No display for message output found with command:\n$mCmd", 'L1', '[DEBUG]');
		return (0);
	}
	return (1);
}



###############################################################################
# prints a message on display informing about an expected long install time
# does nothing if the message was already sent
#
sub messageLongInstall {
	if (($longInstall == 0) && (triesAlreadyDone() < 1)) {
		if (messageDesktop(__('TUXEDO Tomte is installing fixes'),__('Please do not restart or shutdown the system.'), 2, 'dialog-warning')) {
			$longInstall = 1;
		}
	}
}


###############################################################################
# initialize logFile
# create one if not existing already
# exits program if logfile can not be created
#
sub initLogging {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update", "loglevel"} = ();

	# do not log if no arguments
	if ($argValue{command} eq '') {
		return;
	}
	# do not log if false arguments
	if (! (exists $options{$argValue{command}})) {
		return;
	}

	# check if root permissions available
	if (! isRoot()) {
		return;
	}

	my $timestamp;
	# create logDir if it does not exist
	unless ( -d $logDir ) {
		mkdir($logDir, 0755);
		unless ( -d $logDir ) {
			$noLogFile = 1;
			print "Could not create $logDir\n";
			return;
		}
	}
	# check for logfile
	if ( -e $logFile ) {
		# append if logFile exists
		if ( open($LOGFILE, '>>', $logFile) )
		{
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog("starting Tomte $VERSION", 'L0', '[INFO]');
			if ($FAI) {
				printLog('in FAI mode', 'L0', '[INFO]');
			}
			return;
		} else {
			printLog("Err: $!", 'L1', '[ERROR]');
			$noLogFile =1;
			print "[ERROR] Could not open logFile $logFile\n$!\n";
			exit (0);
		}
	} else {
		# create a new logFile
		if ( open($LOGFILE, '>', $logFile) ) {
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog("starting Tomte $VERSION", 'L0', '[INFO]');
			if ($FAI) {
				printLog('in FAI mode', 'L0', '[INFO]');
			}
			return;
		} else {
			printLog("Err: $!", 'L0', 'L1', '[ERROR]');
			$noLogFile =1;
			print "Could not create logFile $logFile\n";
			exit (0);
		}
	}
}



###############################################################################
#
sub getLoggingTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d %02d:%02d:%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
#
sub getBackupFileTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d%02d%02d%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
# prints into logFile or to terminal
# printLog('message', 'tlX', severity)
# it assumes 'l' or 'L' if 't', 'T', 'L' or 'l' are ommited
# loglevels for X:
# 0 highest/errors/fatal
# 1 normal
# 2 debug
# severity is a string which will be put in front of the line
# possible severities are:
# [INFO] [DEBUG] [WARN] [ERROR] [FATAL]
#
sub printLog {
	my ($message, $type, $severity) = @_;
	if ((!defined($type)) || ($type eq '')) {
		$type = 'L1';
	}
	my $level = $type;
	if ($level =~ /[0-2]/) {
		$level =~ s/\D//g;
		$level += 0;
	} else {
		$level = 1;
		$level += 0;
	}
	if ($type =~ /[LlTt]/) {
		$type =~ s/[\W\d]//g;
	} else {
		$type = 'L';
	}

	if ($FAI) {
		print "$severity $message\n";
	} elsif ($level <= $logLevel) {
		if ((-e $logFile) && ($type =~ /L/i)) {
			if (open($LOGFILE, '>>', $logFile) ) {
				my $timestamp = getLoggingTime();
				if (defined($severity)) {
					print $LOGFILE "$severity $timestamp $message\n";
				} else {
					print $LOGFILE "$timestamp $message\n";
				}
				close $LOGFILE;
			}
		}
		if ($type =~ /T/i) {
			print "$message\n";
		}
	}
}


# accepts a file_path and return a hash with the parsed data
sub readTOMLFile {
	my $file_path = shift;

	my $tomlStr = read_file($file_path, 'err_mode' => 'carp');
	my $tomlHashRef = from_toml($tomlStr);

    # Check if the TOML data was parsed successfully
    if (!defined $tomlHashRef) {
        printLog("Failed to parse TOML data from file: $file_path", "TL0", '[ERROR]');
		return {};
    }

	return %$tomlHashRef;
}



###############################################################################
# reads config values from configIniFile
# returns 1 if file exists
# retuns 0 if file does not exist
#
sub readConfigIniValues {
	if (-e $configIniFile) {
		$configIniValues = Config::Tiny->new;
		$configIniValues = Config::Tiny->read($configIniFile, 'utf8');
		if (defined $configIniValues->{debugMode}) {
			printLog("debugLevel before: $logLevel ValueFromIniFile: $configIniValues->{debugMode}", 'L2', '[DEBUG]');
			$logLevel = $configIniValues->{loglevel};
		}
		return (1);
	}
	return (0);
}



###############################################################################
# renames the old config file name to a new name
#
sub renameOldConfigFile {
	if (-e $oldConfigFile) {
		rename($oldConfigFile, $configFile);
	}
}





###############################################################################
# fills global variable %localConfModules with data from $configFile
# if there is no configFile then it is left empty
# returns '0' if configfile can not be read, else returns '1'
#
sub readConfigFile {
	my %comp;
	my $FH;
	my $shortname;
	renameOldConfigFile();
	readConfigIniValues();
	if ( (-e $configFile) && open($FH, '<', $configFile) ) {
		while ( my $line=<$FH> ) {
			chomp $line;
			# ignore comments
			if ($line =~ /^#/) {
				next;
			}
			# ignore empty lines
			if ($line =~ /^(\s)*$/) {
				next;
			}
			# check data format
			if (validConfigLine($line)) {
				my ($name, @cols) = split /\s+/, $line;
				# check if module name exists in orig and return shortname
				$shortname = validModuleName($name);
				if ($shortname ne '') {
					# @comp values have to be same as in writeConfigFile
					@comp{qw(name version installed blocked required hwid)} = ($name, @cols);

					$localConfModules{$shortname} = { %comp };
					# convert to numbers
					$localConfModules{$shortname}{version} = $localConfModules{$shortname}{version} * 1;
					$localConfModules{$shortname}{hwid} = $localConfModules{$shortname}{hwid} * 1;
				} else {
					printLog("module: $name does not exist", 'L1', '[WARN]');
				}
			} else {
				printLog("invalid line in $configFile", 'L0', '[ERROR]');
			}
		}
		close $FH;
	} else {
		printLog("Err: $!", 'L0', '[ERROR]');
		printLog("could not open configFile: $configFile $!", 'TL0', '[ERROR]');
		return (0);
	}
	return (1);
}


###############################################################################
# checks if the line has valid values
# return 0 if invalid, 1 if valid
#
sub validConfigLine {
	my $line = shift;
	# name version installed blocked required hwid
	if ($line =~ /^[a-zA-Z0-9\-\.]+\s[a-zA-Z0-9\-]\s(yes|no|failed|LiveISO)\s(yes|no)\s(yes|no|prerequisite)\s[a-zA-Z0-9\-]\s*$/) {
		return (1);
	} else {
		printLog("found invalid configuration line in $configFile:\n$line", 'L0', '[ERROR]');
		return (0);
	}
}



###############################################################################
# creates $configIniFile if it does not exist
# over writes file with known config data if it exists
#
sub writeConfigIniFile {
	if ($configIniValues->write($configIniFile, 'utf8')) {
		printLog("$configIniFile successfully written", 'L2', '[INFO]');
		return (1);
	} else {
		printLog("problems writing $configIniFile", 'L2', '[WARN]');
		return (0);
	}
}



###############################################################################
# overwrites $configFile with data from $origConfModules if it does not exist
#
sub writeConfigFile {
	my $FH;
	my $installed;
	my $version;
	my $hwid;
	
	if ($FAI) {
		$configIniValues->{installation}->{FAI} = 'first reboot after FAI';
	}
	writeConfigIniFile();

	renameOldConfigFile();
	if ( open($FH, '>', $configFile) ) {
		printLog("writing configfile", 'L1', '[INFO]');
		print $FH "# name version installed blocked required hwid\n";
		foreach my $name (sort keys %origConfModules) {
			# values have to be same as in readConfigFile
			if ($origConfModules{$name}{required} ne 'no') {
				if ($origConfModules{$name}{upgrade} eq 'yes') {
					# upgrade available
					if ($origConfModules{$name}{upgraded} eq 'yes') {
						# upgrade was executed
						printLog("upgrade was executed", 'L2', '[DEBUG]');
						$version = $origConfModules{$name}{version};
						$hwid = $origConfModules{$name}{hwid};
						$installed = $origConfModules{$name}{installed};
					} else {
						# upgrade was not executed
						printLog("upgrade was not executed", 'L2', '[DEBUG]');
						if ( $origConfModules{$name}{installed} eq 'yes' ) {
							$version = $localConfModules{$name}{version};
							$hwid = $localConfModules{$name}{hwid};
							$installed = $localConfModules{$name}{installed};
						} else {
							$version = $origConfModules{$name}{version};
							$hwid = $origConfModules{$name}{hwid};
							$installed = $localConfModules{$name}{installed};
						}
					}
				} else {
					# no upgrade available
					printLog("no upgrade available for $origConfModules{$name}{name}", 'L2', '[DEBUG]');
					$version = $origConfModules{$name}{version};
					$hwid = $origConfModules{$name}{hwid};
					$installed = $origConfModules{$name}{installed};
				}
				unless(($origConfModules{$name}{installed} eq 'no') &&
						($origConfModules{$name}{required} eq 'no')) {
					print $FH "$origConfModules{$name}{name} ".
						"$version ".
						"$installed ".
						"$origConfModules{$name}{blocked} ".
						"$origConfModules{$name}{required} ".
						"$hwid\n";
				}
			}
		}
		close $FH;
		printLog("$configFile successfully written", 'L2', '[DEBUG]');
	} else {
		printLog("Err: $!", 'L0', 'L1', '[ERROR]');
		printLog("can't write to configfile $configFile $!", 'TL0', '[FATAL]');
		exit (0);
	}
}



############################################################################### 
# check if config directory exists
# if not creates a new directory
# if that is not possible, exits (!!!)
#
sub initConfigDir {
	# create configDir if it does not exist
	unless ( -d $configDir ) {
		mkdir($configDir, 0755);
		unless ( -d $configDir ) {
			$noConfigFile = 1;
			printLog("could not create $configDir, that's really bad!!", 'TL0', '[FATAL]');
			exit (0);
		}
	}
	return (1);
}


# loads the config or if non existent
# creates a new directory and configfile
#
sub initConfigFile {
	# create configDir if it does not exist
	initConfigDir();

	# read config file
	renameOldConfigFile();
	if ( -f $configFile ) {
		$noConfigFile = 0;
		readConfigFile();
		return;
	} else {
		# set flag for first installation
		write_file( $tomteFirstInstallFile, {'err_mode' => 'carp'}, 'tomteFirstInstall');
		# create a new configFile
		printLog("no configfile present ... creating one", 'TL', '[INFO]');
		writeConfigFile();
		return;
	}
}


###############################################################################
# searches the sysfs subdirectory for active monitor entries
# and returns them as an array
#
sub findActiveEDIDs {
	my $cards_dir = '/sys/class/drm';
	my $dir_handle;
	my @edidfile;
	my $enabledFileContent;
	my $statusFileContent;

	my $edidTrigger = 0;

	if ( !opendir ($dir_handle, $cards_dir)) {
		printLog("Err: $!", 'L1', '[WARN]');
		printLog("unable to open $cards_dir: $!", 'L1', '[WARN]');
		return @edidfile;
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' } readdir($dir_handle);
	foreach my $file (@FILES) {
		my $path = "$cards_dir/$file";
		if ( -d $path ) {
			my $enabledFile = "$path/enabled";
			if ( -e $enabledFile ) {
				open(my $fh1, '<', $enabledFile);
				$enabledFileContent = <$fh1>;
				close($fh1);
				if ($enabledFileContent =~ /enabled/) {
					my $statusFile = "$path/status";
					if ( -e $statusFile ) {
						if (!-e $file) {
							return (0);
						}
						open(my $fh2, '<', $statusFile);
						$statusFileContent = <$fh2>;
						close($fh2);
						if ($statusFileContent =~ /connected/) {
							push @edidfile, "$path/edid";
							$edidTrigger = 1;
						}
					}
				}
			} else {
				printLog("file $enabledFile not found", 'L2', '[WARN]');
			}
		}
	}
	if (! $edidTrigger ) {
		printLog('no enabled and active edid files found!', 'L1', '[WARN]');
	}
	return @edidfile;
}


###############################################################################
# gets valid edid files
# converts edid data into an array of hash references to origConfModules
#
sub getEDIDData {
	my @edidFiles = findActiveEDIDs();
	my @edidRefs;
	my @edidInfo;
	my $FH;
	my $fileContent;
	foreach ( @edidFiles ) {
		if ( (-e $_) && open($FH, '<', $_) ) {
			$fileContent = do { local $/; <$FH> };
			close $FH;
			push @edidRefs, parse_edid($fileContent);
		} else {
			printLog("Err: $!", 'L1', '[ERROR]');
			printLog("could not open file $_ $!", 'L1', '[ERROR]');
		}
	}
	# returns array of hash references to module
	return @edidRefs;
}



###############################################################################
# returns 1 if the display described by a string is connected, otherwise 0
# the requesting string is build by appending the following data as returned by
# edid-decode
# manufacturer_name Model product_code Serial Number serial_number
# the values from manufacturer_name, product_code and serial_number are
# extracted by Parse::EDID
#
sub isDisplayPresent {
	my $edidSearchString = shift;
	my @edidRefs = getEDIDData();
	my $edidInfo;
	if (@edidRefs == 0) {
		return (0);
	} else {
		foreach my $edidData (@edidRefs) {
			$edidInfo = $$edidData{manufacturer_name}." Model ".$$edidData{product_code}." Serial Number ".$$edidData{serial_number};
			if ($edidInfo =~ /$edidSearchString/) {
				return (1);
			}
		}
	}
	printLog("edid string not found", 'L1', '[WARN]');
	return (0);
}




###############################################################################
# print status from all modules in a nice formated output

###############################################################################
# print status from all modules in a nice formated output
# uses the data from the local configuration file if available
# else it checks the hardware
#
# used pattern:
# installed and new module version equal (no update)
# installed	req. old	req. new	notes
# no		no			no			ign
# yes		no			no			installed but not required!
# no		yes			no			ign
# yes		yes			no			ign
# no		no			yes			ign
# yes		no			yes			ign
# no		yes			yes			not inst. but required
# yes		yes			yes			inst. and req.
#
# installed and new module version not equal (update?)
# to be done in next version
#
sub listStatus {
	my @arr = ( ['Name', 'Version', 'Installed', 'Blocked', 'Required'] );
	my $module;
	my $noneRequired = 1;
	my $printIt = 0;
	my $upgradeAvailable = '';

	foreach $module (sort keys %localConfModules) {
		if($origConfModules{$module}{upgrade} eq 'yes') {
			$upgradeAvailable = ' - upgrade available';
		} else {
			$upgradeAvailable = '';
		}
		if (($localConfModules{$module}{installed} eq 'yes') &&
			($localConfModules{$module}{required} eq 'no') &&
			($origConfModules{$module}{required} eq 'no')) {
			# module is installed but should not be
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}"]);
		}
		# required, installed and not removed
		if (($localConfModules{$module}{required} eq 'yes') ||	($localConfModules{$module}{required} eq 'prerequisite')) {
			$noneRequired = 0;
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}$upgradeAvailable"]);
		}
	}
	if ($printIt) {
		print "Selected installation mode: $mode\n";
		print "Only showing fixes that are available for this hardware\n";
		$~ = "LISTSTATI";
		for my $row (@arr) {
			format LISTSTATI =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @<<<<<<< @<<<<<<<<< @<<<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<
			@$row
.
			write;
		}
	}
	if (-e $needsRestartFile) {
		print "Some fixes need a system restart to be effective\n";
		if ($LiveISO) {
			print "As this is a LiveISO, restarting will not make sense\n";
		}
	}
	if ($noneRequired) {
		print "No fixes available for this system\n";
	}
}




###############################################################################
# print status from all modules in a nice formated output
# uses the data from the local configuration file if available
# else it checks the hardware
#
# used pattern:
# installed and new module version equal (no update)
# installed req. old    req. new    notes
# no        no          no          ign
# yes       no          no          installed but not required!
# no        yes         no          ign
# yes       yes         no          ign
# no        no          yes         ign
# yes       no          yes         ign
# no        yes         yes         not inst. but required
# yes       yes         yes         inst. and req.
#
# installed and new module version not equal (update?)
# to be done in next version
#
sub listVersions {
	my @arr = ( ['Name', 'Packageversion', 'Version', 'Installed', 'Blocked', 'Required'] );
	my $module;
	my $noneRequired = 1;
	my $printIt = 0;
	my $upgradeAvailable = '';

	print "tuxedo-tomte $VERSION\n";

	foreach $module (sort keys %localConfModules) {
		if($origConfModules{$module}{upgrade} eq 'yes') {
			$upgradeAvailable = ' - upgrade available';
		} else {
			$upgradeAvailable = '';
		}
		$localConfModules{$module}{packageVersion} = '';
		if ($module eq 'nvidiadriver') {
			$localConfModules{$module}{packageVersion} = getPackageVersion('nvidia-driver-*');
		}
		if ($module =~ /kernel.*/ ) {
			$localConfModules{$module}{packageVersion} = getPackageVersion($origConfModules{$module}{name});
		}
		if (($localConfModules{$module}{installed} eq 'yes') &&
			($origConfModules{$module}{package} eq 'yes')) {
			$localConfModules{$module}{packageVersion} = getPackageVersion($origConfModules{$module}{name});
			if ($localConfModules{$module}{packageVersion} eq '') {
				$localConfModules{$module}{packageVersion} = 'unkwn';
			}
		}

		if (($localConfModules{$module}{installed} eq 'yes') &&
			($localConfModules{$module}{required} eq 'no') &&
			($origConfModules{$module}{required} eq 'no')) {
			# module is installed but should not be
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{packageVersion}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}"]);
		}
		# required, installed and not removed
		if (($localConfModules{$module}{required} eq 'yes') ||  ($localConfModules{$module}{required} eq 'prerequisite')) {
			$noneRequired = 0;
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{packageVersion}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}$upgradeAvailable"]);
		}
	}
	if ($printIt) {
		print "Selected installation mode: $mode\n";
		print "Only showing fixes that are available for this hardware\n";
		$~ = "LISTVERSIONS";
		for my $row (@arr) {
			format LISTVERSIONS =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @<<<<<<<<<<<<<<<< @<<<<<<< @<<<<<<<<< @<<<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<
			@$row
.
			write;
		}
	}
	if (-e $needsRestartFile) {
		print "Some fixes need a system restart to be effective\n";
		if ($LiveISO) {
			print "As this is a LiveISO, restarting will not make sense\n";
		}
	}
	if ($noneRequired) {
		print "No fixes available for this system\n";
	}
}




sub listStatusJson {
	my $module;
	my $upgradeAvailable = '';
	my %list;

	$list{version} = $VERSION;
	$list{mode} = $mode;
	if (-e $needsRestartFile) {
		$list{restart} = 'yes';
	} else {
		$list{restart} = 'no';
	}
	

	foreach $module (sort keys %localConfModules) {
		if($origConfModules{$module}{upgrade} eq 'yes') {
			$upgradeAvailable = ' - upgrade available';
		} else {
			$upgradeAvailable = '';
		}
		if (($localConfModules{$module}{installed} eq 'yes') &&
			($localConfModules{$module}{required} eq 'no') &&
			($origConfModules{$module}{required} eq 'no')) {
			# module is installed but should not be
			push @{ $list{modules} }, {
				name => $localConfModules{$module}{name},
				version => $localConfModules{$module}{version},
				installed => $localConfModules{$module}{installed},
				blocked => $localConfModules{$module}{blocked},
				required => "$localConfModules{$module}{required}$upgradeAvailable",
			};
		}
		# required, installed and not removed
		if (($localConfModules{$module}{required} eq 'yes') ||	($localConfModules{$module}{required} eq 'prerequisite')) {
			push @{ $list{modules} }, {
				name => $localConfModules{$module}{name},
				version => $localConfModules{$module}{version},
				installed => $localConfModules{$module}{installed},
				blocked => $localConfModules{$module}{blocked},
				required => "$localConfModules{$module}{required}$upgradeAvailable",
			};
		}
	}
	my $jsonText = encode_json \%list;
	print "$jsonText\n";
}





###############################################################################
# copies values from local configuration module into new configuration module
# copies always 'blocked'
#
sub transferConfigValues {
	my $name;
	foreach $name (sort keys %localConfModules) {
		# always copy blocked status
		$origConfModules{$name}{blocked} = $localConfModules{$name}{blocked};
		if (newVersion($name) || newHwid($name)) {
			# new version or new hwid => upgrade necessary
			$origConfModules{$name}{upgrade} = 'yes';
			$origConfModules{$name}{upgraded} = 'no';
		} else {
			$origConfModules{$name}{installed} = $localConfModules{$name}{installed};
			$origConfModules{$name}{upgrade} = 'no';
			$origConfModules{$name}{upgraded} = 'no';
		}
	}
}



###############################################################################
# returns 0 if no new version
# returns 1 if new version
#
sub newVersion {
	my $module = shift;
	if ($localConfModules{$module}{version} < $origConfModules{$module}{version}) {
		return (1);
	} else {
		return (0);
	}
}


###############################################################################
# returns 0 if no new hwid
# returns 1 if new hwid
#
sub newHwid {
	my $module = shift;
	if ($localConfModules{$module}{hwid} < $origConfModules{$module}{hwid}) {
		return (1);
	} else {
		return (0);
	}
}



###############################################################################
# adds module hash to list of configured modules with status
#
sub addToConfiguredModules {
	my $module = shift;
	my $status = shift;
	if (defined($module) && ($module ne '')) {
		$configuredModules{$module} = $status;
		if ($status =~ /failed/) {
			printLog("failed to install $origConfModules{$module}{name}", 'L0', '[ERROR]');
		} elsif ($status =~ /success/) {
			printLog("succesfully installed $origConfModules{$module}{name}", 'L0', '[INFO]');
		} elsif ($status =~ /removed/) {
			if (($mode ne 'DONT_CONFIGURE') || ($mode ne 'UPDATES_ONLY')) {
				printLog("succesfully removed $origConfModules{$module}{name}", 'L0', '[INFO]');
				print "The module $origConfModules{$module}{name} has been removed. Please block it with:\n";
				print "\$ sudo tomte block $origConfModules{$module}{name}\n";
				print "unless you set the mode DONT_CONFIGURE or UPDATE_ONLY\n";
				print "or tomte will reinstall it again at the next start\n";
			}
		} elsif ($status =~ /remove failed/) {
			printLog("failed to remove $origConfModules{$module}{name}", 'L0', '[ERROR]');
		} elsif ($status =~ /nothingToDo/) {
			printLog("nothing to do for $origConfModules{$module}{name}", 'L0', '[INFO]');
		}
	} else {
		printLog("modules not defined at addToConfiguredModules", 'L2', '[ERROR]');
		return (0);
	}
}



###############################################################################
# parses sub name from %origConfModules list from given module parameter name
# returns the name of the module vector found
# returns an empty string if not found
#
sub getSubName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if (defined $origConfModules{$module}{name}) {
			if ( $moduleName eq $origConfModules{$module}{name} ) {
				return $module;
			}
		}
	}
	# return empty string if module is not found
	return "";
}


###############################################################################
# returns the shortname of module if the name is a valid module name
# returns '' if not
#
sub validModuleName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if (defined $origConfModules{$module}{name}) {
			if ($origConfModules{$module}{name} eq $moduleName) {
				return $module;
			}
		}
	}
	return '';
}



###############################################################################
# configures all modules
# if not blocked, required and not installed
#
# u=upgrade
# c=configure
# R=remove
# .=nothing
#
# installed blocked		required	newversion	newhwid
# tomte.cfg	tomte.cfg	check		origConfig	origConfig
# yes		yes			yes			yes			yes		.
# yes		yes			yes			yes			no		.
# yes		yes			yes			no			yes		.
# yes		yes			yes			no			no		.
# yes		yes			no			yes			yes		.
# yes		yes			no			yes			no		.
# yes		yes			no			no			yes		.
# yes		yes			no			no			no		.
# yes		no			yes			yes			yes		u
# yes		no			yes			yes			no		u
# yes		no			yes			no			yes		u
# yes		no			yes			no			no		.
# yes		no			no			yes			yes		R
# yes		no			no			yes			no		R
# yes		no			no			no			yes		R
# yes		no			no			no			no		R
# no		yes			yes			yes			yes		.
# no		yes			yes			yes			no		.
# mo		yes			yes			no			yes		.
# no		yes			yes			no			no		.
# no		yes			no			yes			yes		.
# no		yes			no			yes			no		.
# no		yes			no			no			yes		.
# no		yes			no			no			no		.
# no		no			yes			yes			yes		C
# no		no			yes			yes			no		C
# no		no			yes			no			yes		C
# no		no			yes			no			no		C
# no		no			no			yes			yes		.
# no		no			no			yes			no		.
# no		no			no			no			yes		.
# no		no			no			no			no		.

sub configureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		# prerequisites are automatically ommited (required=prerequisite)
		# they are done in prerequisite and postrequisite subroutines
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{order} ne 'first') && ($origConfModules{$module}{order} ne 'last')) {
			if ($origConfModules{$module}{reconfigure} eq 'always') {
				# reconfigure modules with 'always' every single time
				reconfigureSingleModule($origConfModules{$module}{name});
			} else {
				configureSingleModule($origConfModules{$module}{name});
			}
		} elsif (($origConfModules{$module}{required} eq 'no') &&
				(($localConfModules{$module}{installed} eq 'yes') ||
				($localConfModules{$module}{installed} eq 'failed'))) {
			removeSingleModule($origConfModules{$module}{name});
		}
	}
}



###############################################################################
# configures a single module
# if not blocked, required and not installed
#
sub configureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);

	if ($module eq "") {
		printLog("wrong module name", 'TL', '[WARN]');
		return;
	}

	# check if in LiveISO and exit from subroutine if module should not be
	# installed
	if ($LiveISO && ($origConfModules{$module}{LiveISO} eq 'no')) {
		printLog("Module: $module will not be installed as this is a LiveISO", 'L0', '[WARN]');
		addToConfiguredModules($module, 'nothingToDo');
		$localConfModules{$module}{installed} = 'LiveISO';
		return;
	}

	# grub file should always be checked for correct entries if there
	# is a fix available for this system
	if ( (($localConfModules{$module}{installed} eq 'no') ||
		($localConfModules{$module}{installed} eq 'failed') ||
	   	($origConfModules{$module}{postconf} eq 'updateGrub')) &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes') {
		printLog("configure module: $module", 'L1', '[INFO]');
		configureModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes' &&
		$origConfModules{$module}{upgrade} eq 'yes' ) {
		# upgrade if new version or hwid
		printLog("upgrade module: $module", 'L1', '[INFO]');
		updateModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' ) {
		$configuredModules{$module} = 'nothingToDo';
	}
	if (($localConfModules{$module}{blocked} eq 'yes') &&
		($origConfModules{$module}{required} ne 'prerequisite') &&
   		($mode ne 'DONT_CONFIGURE') &&
		($mode ne 'UPDATES_ONLY')) {
		print "Module $moduleName cannot be installed/removed/updated because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
}



###############################################################################
# checks if the conditions to remove a module are met
#
sub removeSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);

	if ($module eq "") {
		printLog("wrong module name", 'TL', '[WARN]');
		return;
	}

	if ($localConfModules{$module}{blocked} eq 'no') {
		printLog("removing module $moduleName", 'TL', '[INFO]');
		removeModule($module);
	}	

	if ( $localConfModules{$module}{blocked} eq 'yes' ) {
		print "Module $moduleName cannot be removed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
}



###############################################################################
# reconfigures all modules if not blocked and if required even if it is
# already installed
# ommits modules which are "prerequisite" or as order "first" or "last"
#
sub reconfigureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{order} ne 'first') && ($origConfModules{$module}{order} ne 'last')) {
			reconfigureSingleModule($origConfModules{$module}{name});
		} elsif (($origConfModules{$module}{required} eq 'no') &&
				(($localConfModules{$module}{installed} eq 'yes') || ($localConfModules{$module}{installed} eq 'failed'))) {
			removeModule($module);
		}
	}
}



###############################################################################
# reconfigures a single module if not blocked and if required or prerequisite
# even if it is already installed
#
sub reconfigureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	printLog("reconfigureSingleModule: $moduleName", 'L2', '[INFO]');

	if ($module eq "") {
		printLog("wrong module name", 'TL', '[WARN]');
		return;
	}

	# check if in LiveISO and exit from subroutine if module should not be
	# installed
	if ($LiveISO && ($origConfModules{$module}{LiveISO} eq 'no')) {
		printLog("Module: $module will not be reconfigured as this is a LiveISO", 'L0', '[WARN]');
		addToConfiguredModules($module, 'nothingToDo');
		$localConfModules{$module}{installed} = 'LiveISO';
		return;
	}

	if (($origConfModules{$module}{required} eq 'prerequisite') ||
		(($localConfModules{$module}{blocked} eq 'no') && ($origConfModules{$module}{required} eq 'yes'))) {

		if ($origConfModules{$module}{upgrade} eq 'yes') {
			printLog("upgrade module: $module", 'L1', '[INFO]');
			updateModule($module);
		} else {
			printLog("configure module: $module", 'L1', '[INFO]');
			configureModule($module);
		}
	} elsif ( $localConfModules{$module}{installed} eq 'yes' ) {
		$configuredModules{$module} = 'nothingToDo';
	}

	if (($localConfModules{$module}{blocked} eq 'yes') &&
		($origConfModules{$module}{required} ne 'prerequisite') &&
   		($mode ne 'DONT_CONFIGURE') &&
		($mode ne 'UPDATES_ONLY')) {
		printLog("module $module is blocked", 'L2', '[INFO]');
		print "Module: $moduleName cannot be installed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
		if ($LiveISO) {
			print "this block has probably been set by the distribution maintainer\n";
			print "as it does not make much sense to install this module at this stage\n";
		}
	}

	if (($origConfModules{$module}{required} eq 'no') &&
		($configuredModules{$module} ne 'remove failed') &&
		($configuredModules{$module} ne 'removed')) {
		printLog("module $module is not required by this system", 'L2', '[INFO]');
		print "Module: $moduleName cannot be installed because:\n";
		print "- it is not required by this system (this is the main reason)\n";
	}
}




###############################################################################
# blocks a module
# block( $moduleName )
#
sub block {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	printLog("block module: >$module<", 'L2', '[INFO]');
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($origConfModules{$module}{required} eq 'prerequisite') {
		print "Module $moduleName is a prerequisite and can't be blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Module $moduleName is already blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Blocking module $moduleName\n";
		print "$moduleName will not be upgraded or reinstalled if removed\n";
		$origConfModules{$module}{blocked} = 'yes';
		printLog("blocking module $moduleName", 'L1', '[INFO]');
		return;
	}
}

###############################################################################
# unblocks a module
#
sub unblock {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	printLog("unblock module: >$module<", 'L2', '[INFO]');
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Module $moduleName is not blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Unblocking module $moduleName\n";
		$origConfModules{$module}{blocked} = 'no';
		printLog("unblocking module $moduleName", 'L1', '[INFO]');
		return;
	}
}


###############################################################################
# blocks all modules
#
sub blockAllModules {
	my $module;
	foreach $module (keys %origConfModules) {
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{blocked} ne 'yes') &&
			($origConfModules{$module}{required} ne 'prerequisite')) {
			$origConfModules{$module}{blocked} = 'yes';
			printLog("blocking module $origConfModules{$module}{name}", 'TL0', '[INFO]');
		}
	}
}



###############################################################################
# unblocks all modules
#
sub unblockAllModules {
	my $module;
	foreach $module (keys %origConfModules) {
		if (($origConfModules{$module}{required} eq 'yes') &&
			($origConfModules{$module}{blocked} eq 'yes')) {
			$origConfModules{$module}{blocked} = 'no';
			printLog("unblocking module $origConfModules{$module}{name}", 'TL0', '[INFO]');
		}
	}
}




###############################################################################
# set configuration mode setMode('mode')
# AUTOMATIC: install/remove/update everything automatically
# UPDATES_ONLY: only update installed modules
# DONT_CONFIGURE: do not configure anything
#
sub setMode {
	my $requestedMode = shift;
	my $key;

	$mode = checkMode();
	if ($mode eq $requestedMode) {
		printLog("Requested mode '$requestedMode' is already set", 'TL0', '[INFO]');
	} else {
		foreach $key (keys %modeFile) {
			if ($key eq $requestedMode) {
				write_file($modeFile{$requestedMode}, {'err_mode' => 'carp'}, '');
				printLog("creating modefile: $modeFile{$requestedMode} for $requestedMode", 'TL0', '[INFO]');
			} elsif (-e $modeFile{$key}) {
				unlink($modeFile{$key});
				printLog("removing superfluous modefile: $modeFile{$key}", 'TL2', '[INFO]');
			}
		}
	}
}



###############################################################################
# returns the mode configured as file in the configuration directory
# 'AUTOMATIC', 'UPDATES_ONLY' or 'DONT_CONFIGURE'
#
sub checkMode {
	my $tmpMode;
	my $countModes = 0;
	if (-e $modeFile{AUTOMATIC}) {
		++$countModes;
		$mode = 'AUTOMATIC';
	}
	if (-e $modeFile{UPDATES_ONLY}) {
		++$countModes;
		$mode = 'UPDATES_ONLY';
	}
	if (-e $modeFile{DONT_CONFIGURE}) {
		++$countModes;
		$mode = 'DONT_CONFIGURE';
	}
	if ($countModes == 0) {
		$mode = 'AUTOMATIC';
		printLog('No mode setting found, assuming AUTOMATIC', 'L2', '[INFO]');
		$mode = 'AUTOMATIC';
	}
	if ($countModes == 1) {
		printLog("Found mode setting $mode", 'L2', '[INFO]');
	}
	if ($countModes > 1) {
		printLog("More then one mode setting found, assuming $mode", 'L2', '[INFO]');
	}
	return $mode;
}



###############################################################################
# checks if the operation is allowed in this mode/command/module
# usage: checkModePermision(install|remove|update, MODULE)
# returns 0 if not and 1 if allowed
#
sub checkModePermission {
	my ($operation, $module) = (@_);
	# this is a double check, just in case ...

	if ($origConfModules{$module}{required} eq 'prerequisite') {
		printLog("module is prerequisite", 'L2', '[INFO]');
		# always permit if it is a prerequisite
		return (1);
	}
	# when FAI assume yes on all
	if ($argValue{command} eq 'FAI') {
		return (1);
	}
	# when Live ISO or FAI assume yes on all
	if ($LiveISO || $FAI) {
		return (1);
	}
	if ($argValue{command} eq 'configure') {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	if ($argValue{command} eq "reconfigure") {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	if ($argValue{command} eq "remove") {
		if ($argValue{module} eq 'all') {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (0);
				}
				if ($operation eq 'update') {
					return (0);
				}
				if ($operation eq 'remove') {
					return (0);
				}
			}
		} else {
			if ($mode eq 'AUTOMATIC') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'UPDATES_ONLY') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
			if ($mode eq 'DONT_CONFIGURE') {
				if ($operation eq 'install') {
					return (1);
				}
				if ($operation eq 'update') {
					return (1);
				}
				if ($operation eq 'remove') {
					return (1);
				}
			}
		}
	}
	# just to be safe return 0
	return (0);
}



###############################################################################
# configures a module, does no checks
#
sub configureModule {
	my $module = shift;
	my $permission = checkModePermission('install', $module);
	printLog("configure module: $module permission: $permission", 'L2', '[INFO]');
	if ($permission) {
		$module->($module, 'install');
	}
}


###############################################################################
# remove a module, does no checks
#
sub removeModule {
	my $module = shift;
	my $permission = checkModePermission('remove', $module);
	printLog("remove module: $module permission: $permission", 'L2', '[INFO]');
	if ($permission) {
		$module->($module, 'remove');
	}
}



###############################################################################
# configures a module, does no checks
#
sub updateModule {
	my $module = shift;
	my $permission = checkModePermission('update', $module);
	printLog("upgrade module: $module permission: $permission", 'L2', '[INFO]');
	if ($permission) {
		$module->($module, 'upgrade');
	}
}



###############################################################################
# remove warning message and confirmation
# removeWarningMessage('message')
# returns 1 if answered with y or Y
# returns 0 otherwise
# checks if in a valid tty => returns 1
#
sub removeWarningMessage {
	my $message = shift;
	my $answer;
	if (!isatty()) {
		return (1);
	}
	if ($FAI || $LiveISO) {
		return (1);
	}
	if ($message ne '') {
		print "$message";
	}
	print "Are you sure you want to remove this module? (y/n) ";
	chomp($answer = <STDIN>);
	if (($answer eq 'y') || ($answer eq 'Y')) {
		return (1);
	} else {
		return (0);
	}
}




###############################################################################
# checks if we are in a terminal
# returns 1 if yes
# returns 0 if not
#
sub isatty {
	no autodie;
	my $ttyDevice = '/dev/tty';
	if (!-e $ttyDevice) {
		return (0);
	}
	state $isatty = open(my $tty, '+<', $ttyDevice);
	return $isatty;
}




###############################################################################
# starts system programs (if necessary) to activate the module changes
#
sub postConfigure {
	my $sysProgram;
	my $exitStatus;
	my $postConfTrigger = 0;
	my $output;
	my $command;
	printLog("initializing post-configuration", 'TL0', '[INFO]');
	foreach $sysProgram (keys %postConfProgram) {
		if ($postConfProgram{$sysProgram}{trigger} == 1 ) {
			printLog("starting $sysProgram", 'L1', '[INFO]');
			$command = $postConfProgram{$sysProgram}{command}.' 2>&1';
			$output = `$command`;
			$exitStatus = $?;
			if ($exitStatus == 0) {
				printLog("success: $postConfProgram{$sysProgram}{command}", 'L1', '[INFO]');
				postSetModulesState($sysProgram, "success");
				setRestartValues($sysProgram);
			} else {
				$postConfTrigger = 1;
				printLog("failed: $postConfProgram{$sysProgram}{command}", 'L0', '[WARN]');
				printLog("returned error code: $exitStatus", 'L0', '[WARN]');
				postSetModulesState($sysProgram, "failed");
			}
		}
	}
	if ($postConfTrigger == 1) {
		startTomteDelayed();
	}
}




###############################################################################
# Starts the tuxedo-tomte service for delayed configuration
# procedure accepts an optional message startTomteDelayed("message")
#
sub startTomteDelayed {
	my $message = shift;
	my $retVal;
	$restartSystem = 0;
	my $triesValue;

	if ($LiveISO) {
		printLog("not starting Tomte delayed as this is a live ISO", 'L0', '[INFO]');
		return (0);
	}
	if ($FAI) {
		printLog("not starting Tomte delayed as this is a FAI installation", 'L0', '[INFO]');
		return (0);
	}
	if (defined($configIniValues->{installation}->{FAI}) &&
		(($configIniValues->{installation}->{FAI} eq 'first reboot after FAI') ||
		($configIniValues->{installation}->{FAI} eq 'second reboot after FAI'))) {
		printLog("not starting Tomte delayed as this is in OEM configuration", 'L0', '[INFO]');
		return (0);
	}

	printLog("start later again: $startLaterAgain", 'L2', '[INFO]');
	if ($startLaterAgain != 1) {
		$triesValue = tries($triesLimit);
		if (! $triesValue) {
			printLog("repeat limit reached, program will not start again, tries: $triesValue", 'L2', '[INFO]');
			$startLaterAgain = 1;
			if ($restartSystem) {
				messageDesktop(__('Restart required'), __('Please restart the system for the changes to take effect. Tomte could not install all the fixes and will try again the next time it is activated'), 2, 'dialog-warning');
				print "\nPlease restart the system for the changes to take effect, not all the fixes could be installed\n";
			} else {
				if (defined($message)) {
					messageDesktop(__('Tomte ready'), $message, 2, 'dialog-warning');
				} else {
					messageDesktop(__('Tomte ready'), __('Tomte could not install all the fixes and will try again the next time it is activated'), 2, 'dialog-warning');
					print "\nNot all the fixes could be installed\n";
				}
			}
			return (1);
		} else {
			printLog("program will start again, tries: $triesValue, trieslimit: $triesLimit", 'L2', '[INFO]');
		}
	}
	if ($startLaterAgain == 0) {
		$startLaterAgain = 1;
		# This might not be completely reliable, specially when starting a fresh installed system
		my $systemctlCmd = 'systemd-run --on-active="'.$systemdDelay.'sec" tuxedo-tomte configure all >/dev/null 2>&1';

		printLog("systemctlCmd: $systemctlCmd", 'TL0', '[DEBUG]');
		printLog("starting \"systemd-run tuxedo-tomte configure all\" for delayed configuration", 'L0', '[DEBUG]');
		$retVal = system($systemctlCmd);
		printLog("ret value: $retVal", 'L0', '[DEBUG]');
	}
	return (0);
}



###############################################################################
# sets all modules dependant of some system program to work to status failed
#
sub postSetModulesState {
	my $sysProgram = shift;
	my $status = shift;
	my $module;
	$postConfProgram{$sysProgram}{status} = $status;
	foreach $module (keys %configuredModules) {
		$configuredModules{$module}{status} = $status;
	}
}


###############################################################################
# lists which modules and system programs where installed, configured
# or executed correctly and which not
#
sub listSuccess {
	my $confProgram;
	my $confModule;
	my @failedPrograms;
	my @failedModules;
	my @successModules;
	my @nothingToDoModules;
	my @removedModules;
	my $successOrFailed = 0;

	foreach $confProgram (keys %postConfProgram) {
		if ($postConfProgram{$confProgram}{status} eq "failed") {
			$successOrFailed = 1;
			push(@failedPrograms, $postConfProgram{$confProgram}{command});
		}
	}
	foreach $confModule (keys %configuredModules) {
		if ($configuredModules{$confModule} eq "failed") {
			$successOrFailed = 1;
			push(@failedModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "success") {
			$successOrFailed = 1;
			push(@successModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "nothingToDo") {
			push(@nothingToDoModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "removed") {
			push(@removedModules, $confModule);
		}
	}
	if (@successModules) {
		print "\nThe following modules have been installed successfully:\n";
		printNameDescriptionModules(@successModules);
	}
	if (@failedModules) {
		print "\nThe following modules have failed to be installed:\n";
		if (triesAlreadyDone() <= $triesLimit) {
			unless ($LiveISO) {
				print "Tomte will try to install them again in a few minutes\n";
			}
		}
		printNameDescriptionModules(@failedModules);
	}
	if (@nothingToDoModules) {
		print "\nNothing was done for the following modules:\n";
		printNameDescriptionModules(@nothingToDoModules);
	}
	if (@failedPrograms) {
		print "\nThe following post installation programs have failed:\n";
		printNameDescriptionPrograms(@failedPrograms);
	}
	if (@removedModules) {
		print "\nThe following modules have been removed:\n";
		printNameDescriptionModules(@removedModules);
	}
	if (! $successOrFailed) {
		print "\nNothing to do in post configuration\n";
	}
	if ($restartSystem == 1) {
		messageDesktop(__('Restart required'), __('Please restart the system for the changes to take effect.'), 2, 'dialog-warning');
		print "\nPlease restart the system for the changes to take effect\n";
	} elsif ( configuredModulesExceptDefault(@successModules) ) {
		messageDesktop(__('TUXEDO Tomte ready'), __('TUXEDO Tomte finished applying all the required fixes available for this system.'), 1, 'dialog-information');
	}
}



###############################################################################
# returns 1 if any modules except defined ones were configured
# returns 0 if otherwise
#
sub configuredModulesExceptDefault {
	my @modulesList = @_;
	my @defaultModules = ( 'tuxedorepos', 'tuxedomirrors' );
	foreach ( @defaultModules ) {
		for my $index (reverse 0..$#modulesList) {
			if ($modulesList[$index] =~ /$_/) {
				splice(@modulesList, $index, 1, ());
			}
		}
	}
	if ((scalar(@modulesList) > 0) || ($longInstall == 1)) {
		return (1);
	}
	return (0);
}



###############################################################################
# print name and description from modules given as array
#
sub printNameDescriptionModules {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $origConfModules{$element}{name}: $origConfModules{$element}{description}\n";
	}
}


###############################################################################
# print name and description for programs given as array
#
sub printNameDescriptionPrograms {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $element: $postConfProgram{$element}{description}\n";
	}
}


###############################################################################
# show description of module
#
sub moduleDescription {
	my $moduleName = $argValue{module};
	my $module;
	if ($moduleName) {
		$module = getSubName($moduleName);
		if ( $module ne "" ) {
	    print "$origConfModules{$module}{description}\n";
		} else {
			print "module: $moduleName is not in the modules list\n";
		}
    } else {
		print "Missing module name\n";
	}
}



###############################################################################
# show all modules
#
sub modulesList() {
	my $module;
	foreach $module (keys %origConfModules) {
		print "$origConfModules{$module}{name}\n";
	}
}



###############################################################################
# sets values to restart the system
#
sub setRestartValues {
	my $element = shift;
	$restartSystem = 1;
	printLog("setting restart for: $element", 'L2', '[DEBUG]');
	write_file($needsRestartFile, {'err_mode' => 'carp'}, 'Tomte: system has to be restarted');
}




###############################################################################
# limits number of tries Tomte will do to accomplish some task
# returns 0 if limit has been reached
# returns 1 if limit is not reached
#
sub tries() {
	my $limit = shift;
	printLog("tries: given limit: $limit", 'L2', '[DEBUG]');
	if (-e $triesFile) {
		my $triesDone = triesAlreadyDone();
		printLog("repeat number $triesDone of $limit", 'L0', '[DEBUG]');
		if ( $triesDone < $limit ) {
			printLog("rising tries, triesDone below limit", 'L2', '[DEBUG]');
			write_file($triesFile, {'err_mode' => 'carp'}, $triesDone+1);
			return (1);
		} else {
			printLog("limit tries done reached", 'L2', '[DEBUG]');
			printLog('deleting triesFile', 'L2', '[DEBUG]');
			unlink($triesFile);
			return (0);
		}
	} else {
		printLog('creating triesFile', 'L2', '[DEBUG]');
		write_file($triesFile, {'err_mode' => 'carp'}, '1');
	}
	return (1);
}




###############################################################################
# returns how many times Tomte got repeated
#
sub triesAlreadyDone() {
	if (-e $triesFile) {
		return (readFirstLineOfFile($triesFile)+0);
	} else {
		return (0);
	}
}



###############################################################################
# prints help
#
sub help {
	print "tuxedo-tomte $VERSION\n";
	print __('HELP_tuxedo-tomte'), "\n", __('HELP_tomte'). "\n";
	print __('HELP_list'), "\n";
	print __('HELP_status'), "\n";
	print __('HELP_versions'), "\n";
	print __('HELP_modules'), "\n";
	print __('HELP_description_MODULE'), "\n";
	print __('HELP_configure_MODULE'), "\n";
	print __('HELP_reconfigure_MODULE'), "\n";
	print __('HELP_remove_MODULE'), "\n";
	print __('HELP_block_MODULE'), "\n";
	print __('HELP_unblock_MODULE'), "\n";
	print __('HELP_AUTOMATIC'), "\n";
	print __('HELP_UPDATES_ONLY'), "\n";
	print __('HELP_DONT_CONFIGURE'), "\n";
	print __('HELP_loglevel'), "\n";
	print __('HELP_help'), "\n";
	print "\n\n";
	print __('HELP_footer'), "\n";
	exit 0;
}



###############################################################################
# checks if root and returns 1 if yes, otherwise 0
# also sets a global variable
#
sub isRoot {
	# check if root
	if( $> != 0 ) {
		$runningAsRoot = 0;
		return (0);
	}
	$runningAsRoot = 1;
	return (1);
}



###############################################################################
# checks system requirements, loads configfile
#
sub prepareValues {
	checkRequirements();
	initAvailablePackagesList();
	initConfigFile();
	transferConfigValues();
	reportPlannedChanges();
}



###############################################################################
# report planned changes according to list of installed modules and modules yet
# to be installed
#
sub reportPlannedChanges {
	my $module;
	foreach $module (sort keys %origConfModules) {
		if ($origConfModules{$module}{required} eq 'yes') {
			if (($localConfModules{$module}{installed} eq 'no') &&
				($localConfModules{$module}{blocked} eq 'no') &&
				(checkModePermission('install', $module))) {
				printLog("module $module will be installed", 'L0', '[INFO]');
			}
		}
	}
}




###############################################################################
# checks if this is a TUXEDO device
#
sub tuxedoDevice {
	if ((defined $boardname) && (defined $boardvendor) && (defined $sysvendor)) {
		if ($boardname =~ /P64_HJ,HK1/) {
      return (1);
    }
		if ($boardname =~ /P65_P67RGRERA/) {
			return (1);
		}
		if ($boardvendor =~ /TUXEDO/) {
			return (1);
		}
		if ($sysvendor =~ /TUXEDO/) {
			return (1);
		}
		if ($boardname =~ /LAPQC71[AB]/) {
			return (1);
		}
	}
	return (0);
}



###############################################################################
# checks if this is a notebook
# returns 'notebook' if a notebook was detected
# returns 'desktoppc' if a desktop pc was detected
# returns 0 if there was an error or nothing was detected
#
sub getChassisType {
	my $fileName = '/sys/devices/virtual/dmi/id/chassis_type';
	my $chassisTypeNbr;
	my $FH;
	if ((-e $fileName) && open($FH, "<", $fileName)) {
		$chassisTypeNbr = <$FH>;
		$chassisTypeNbr =~ s/\n//g;
	}
	if ($chassisTypeNbr eq '3') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '4') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '6') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '7') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '8') { return ('notebook'); }
	if ($chassisTypeNbr eq '9') { return ('notebook'); }
	if ($chassisTypeNbr eq '10') { return ('notebook'); }
	if ($chassisTypeNbr eq '17') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '34') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '35') { return ('desktoppc'); }
	if ($chassisTypeNbr eq '36') { return ('desktoppc'); }
	my $hostnamectlCmd = $consoleLanguage.'hostnamectl';
	my $returnHostnamectl = `$hostnamectlCmd`;
	if ($returnHostnamectl =~ /^\s+Chassis: vm/gm) {
		printLog("chassis is a virtual machine", 'TL2', '[DEBUG]');
		printLog("machine will be treated as desktoppc", 'TL2', '[DEBUG]');
		return ('desktoppc');
	}
	return ('0');
}





###############################################################################
###############################################################################
###############################################################################
###############################################################################
# MAIN PROGRAM

$chassisType = getChassisType();
printLog("chassistype will be: $chassisType", 'TL2', '[DEBUG]');
if ($chassisType eq '0') {
	print "Something went wrong and I could not determine what type of system this might be ...\n";
	exit (0);
}

if ((!tuxedoDevice()) && ($chassisType eq 'notebook')) {
	print "It seems that this is not a TUXEDO device. Please contact TUXEDO Computers if this is a mistake.\n";
	exit (0);
}

readOSData();

if (!isOSSupported()) {
	exit (0);
}

# define for each argvalues procedures
# modify $USAGE if any modifications are made here

if (@ARGV != 0) {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update", "loglevel"} = ();

	if (exists $options{$argValue{command}} && (! isRoot() )) {
		print "You must have root access to use this option\n";
		exit (0);
	}

	# check whether it is a LiveISO installation
	# checks if directory /fll exists
	if ((-d '/fll') && isTextInFile('/proc/cmdline', 'fll')) {
		$LiveISO = 1;
	}

	# list
	if (($argValue{command} eq "list") || ($argValue{command} eq "status")) {
		checkMode();
		renameOldConfigFile();
		if (!-e $configFile) {
			print "no config file present yet, please use 'sudo tomte list' or 'sudo tomte status' to initialize one\n";
		} else {
			prepareValues();
		}
		listStatus();

	# versions
	} elsif ($argValue{command} eq "versions") {
		checkMode();
		renameOldConfigFile();
		if (!-e $configFile) {
			print "no config file present yet, please use 'sudo tomte list' or 'sudo tomte status' to initialize one\n";
		} else {
			prepareValues();
		}
		listVersions();

	# modules
	} elsif ($argValue{command} eq "modules") {
		modulesList();

	# printcompletefixeslist
	} elsif ($argValue{command} eq "printcompletefixeslist") {
		printTuxedoDevices();

	# listJSON
	} elsif ($argValue{command} eq "listjson") {
		checkMode();
		renameOldConfigFile();
		if (!-e $configFile) {
			print "no config file present yet, please use 'sudo tomte list' or 'sudo tomte status' to initialize one\n";
		} else {
			prepareValues();
		}
		listStatusJson();

	# description
	} elsif ($argValue{command} eq "description") {
		moduleDescription();

	# help
	} elsif ($argValue{command} eq "help") {
		help();

	# FAI
	} elsif ($argValue{command} eq "FAI") {
		print "Starting tuxedo-tomte $VERSION in FAI mode\n".
				"This should not be used in a normal situation\n".
				"only when installing a new system with FAI\n";
		$FAI = 1;
		initLogging();
		setMode('AUTOMATIC');
		prepareValues();
		configureAllModules();
		postConfigure();
		listSuccess();
		writeConfigFile();

	# configure
	} elsif ($argValue{command} eq "configure") {
		# check if there is a second argument
		if ($argValue{module} ne '') {
			initLogging();
			checkMode();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				if ($LiveISO) {
					printLog("starting Tomte in LiveISO mode", 'L0', '[INFO]');
					print "Starting tuxedo-tomte $VERSION in LiveISO mode\n".
					"This should not be used in a normal situation\n".
					"only when installing a new system with LiveISO\n";
				}
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("Mode DONT_CONFIGURE is set", 'TL0', '[INFO]');
					printLog("only prerequisite modules will be installed", 'TL0', '[INFO]');
				}
				# Update Tuxedo Tomte to ensure current version
				if (! ($LiveISO or $FAI)){
					if (unlockPM("apt-get -yq install tuxedo-tomte") && (isPMlocked() == 0)) {
						my $retval;
						printLog("executing tuxedo-tomte installation", 'L2', '[DEBUG]');
						if ($logLevel > 1) {
							$retval = `apt-get -yq -o Dpkg::lock::timeout=0 install tuxedo-tomte >>$logFile 2>&1`;
						} else {
							$retval = `apt-get -yq -o Dpkg::lock::timeout=0 install tuxedo-tomte >/dev/null 2>&1`;
						}
						lockPM();
						printLog("return from apt-get:\n$retval", 'L2', '[DEBUG]');
					} else {
						printLog("Couldn't get PM-Locks for 'apt-get -yq install tuxedo-tomte'", 'L1', '[DEBUG]');
					}
				}
				configureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
			} elsif (validModuleName($argValue{module}) ne '') {
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("Mode DONT_CONFIGURE is set", 'TL0', '[INFO]');
					printLog("only prerequisite modules will be installed", 'TL0', '[INFO]');
				}
				configureSingleModule($argValue{module});
				postConfigure();

				listSuccess();
				writeConfigFile();
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L0', '[INFO]');

	# remove
	} elsif ($argValue{command} eq "remove") {
		if ($argValue{module} ne '') {
			if (validModuleName($argValue{module}) ne '') {
				initLogging();
				checkMode();
				prepareValues();
				prerequisites();
				removeSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L0', '[INFO]');

	# reconfigure
	} elsif ($argValue{command} eq "reconfigure") {
		# reconfigure interrupts repeated execution
		if (-e $triesFile) {
			printLog('delete triesFile', 'L2', '[DEBUG]');
			unlink($triesFile);
		}
		if ($argValue{module} ne '') {
			initLogging();
			checkMode();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("DONT_CONFIGURE is set", 'TL0', '[INFO]');
					printLog("only prerequisite modules will be installed", 'TL0', '[INFO]');
				}
				reconfigureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
			} elsif (validModuleName($argValue{module}) ne '') {
				if ($mode eq 'DONT_CONFIGURE') {
					printLog("DONT_CONFIGURE is set", 'TL0', '[INFO]');
					printLog("only prerequisite modules will be installed", 'TL0', '[INFO]');
				}
				reconfigureSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name or \"all\" missing\n";
		}
		printLog('Tomte finished', 'L0', '[INFO]');

	# blocking/unblocking should work in any mode
	# block
	} elsif ($argValue{command} eq "block") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			if ($argValue{module} eq 'all') {
				blockAllModules();
				writeConfigFile();
				printLog('Tomte finished', 'L1', '[INFO]');
			} elsif (validModuleName($argValue{module}) ne '') {
				block($argValue{module});
				writeConfigFile();
				printLog('Tomte finished', 'L0', '[INFO]');
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name missing\n";
		}

	# unblock
	} elsif ($argValue{command} eq "unblock") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			if ($argValue{module} eq 'all') {
				unblockAllModules();
				writeConfigFile();
				printLog('Tomte finished', 'L1', '[INFO]');
			} elsif (validModuleName($argValue{module}) ne '') {
				unblock($argValue{module});
				writeConfigFile();
				printLog('Tomte finished', 'L0', '[INFO]');
			} else {
				print "module $argValue{module} does not exist\n";
			}
		} else {
			print "Module name missing\n";
		}

	# modes
	} elsif (($argValue{command} eq "DONT_CONFIGURE") ||
			($argValue{command} eq "AUTOMATIC") ||
			($argValue{command} eq "UPDATES_ONLY")) {
		initLogging();
		setMode($argValue{command});
		prepareValues();
		printLog('Tomte finished', 'L0', '[INFO]');
	} elsif ($argValue{command} eq "loglevel") {
		printLog("before loglevel: $logLevel requested loglevel: $argValue{module}", 'L2', '[DEBUG]');
		if (defined($argValue{module}) && $argValue{module} ne '') {
			$argValue{module} += 0;
			if (($argValue{module} >= 0) && ($argValue{module} < 3)) {
				$logLevel = $argValue{module};
				$logLevel += 0;
				printLog("resulting loglevel: $logLevel", 'L2', '[DEBUG]');
				$configIniValues->{initvalues}->{loglevel} = $logLevel;
				writeConfigIniFile();
			} else {
				printLog("invalid entry for loglevel. Valid numbers are 0, 1 and 2", 'TL0', '[DEBUG]');
			}
		} else {
			printLog("$logLevel", 'T0', '[DEBUG]');
		}
	} else {
		print "Unknown command: $argValue{command}\n";
		help();
	}
} else {
	help();
}

# interrupt repeated delayed execution if not necessary anymore
if (($startLaterAgain == 0) &&
	(($argValue{command} eq 'configure') || ($argValue{command} eq 'reconfigure'))) {
	if (-e $triesFile) {
		if (-w $triesFile) {
			printLog('deleting triesFile', 'L2', '[DEBUG]');
			unlink($triesFile);
		}
	}
}

END {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update", "loglevel"} = ();
	if ( exists $options{$argValue{command}} && $runningAsRoot ) {
		if (!$FAI) {
			my $packagekitEnabled = getSystemdEnabled('packagekit');
			$packagekitState = getSystemdState('packagekit');
			printLog("\npackagekitEnabled: $packagekitEnabled\npackagekitOriginalEnabled: $packagekitOriginalEnabled\npackagekitState: $packagekitState\npackagekitOriginalState: $packagekitOriginalState", 'L2', '[DEBUG]');
			if ($packagekitEnabled ne $packagekitOriginalEnabled) {
				printLog("packagekit enabled was originally: $packagekitOriginalEnabled now: $packagekitEnabled", 'L2', '[DEBUG]');
				if ($packagekitOriginalEnabled eq 'enabled') {
					commandSystemdModule('unmask', 'packagekit');
				}
			}
			if ($packagekitOriginalState ne $packagekitState) {
				printLog("packagekit was originally: $packagekitOriginalState it is now: $packagekitState", 'L2', '[DEBUG]');
				if ($packagekitOriginalState eq 'active') {
					commandSystemdModule('enable', 'packagekit');
				}
			}
		}
	}
	if ($runningAsRoot) {
		if ($distribution eq 'TUXEDO OS') {
			if ($FAI || $LiveISO) {
				# do nothing special for now
			} elsif (!$FAI && defined($configIniValues->{installation}->{FAI}) && ($configIniValues->{installation}->{FAI} eq 'first reboot after FAI')) {
				# this happens when in OEM stage after a FAI installation,
				# if the OEM stage gets interrupted by a reboot or shutdown
				# if you reboot the system after a FAI installation in OEM, please,
				# just make a new FAI installation! to make sure everything is proper
				printLog("after FAI installation detected, this is probably the OEM stage", 'L2', '[DEBUG]');
				my $calamaresProcesses = `pgrep -c calamares`;
				printLog("calamares processes found: $calamaresProcesses", 'L2', '[DEBUG]');
				printLog("first boot out of OEM, setting second reboot flag", 'L2', '[DEBUG]');
				$configIniValues->{installation}->{FAI} = 'second reboot after FAI';
				writeConfigIniFile();
			} elsif (!$FAI && defined($configIniValues->{installation}->{FAI}) && ($configIniValues->{installation}->{FAI} eq 'second reboot after FAI')) {
				printLog("after FAI installation second stage detected, this is probably the OEM stage", 'L2', '[DEBUG]');
				my $calamaresProcesses = `pgrep -c calamares`;
				if ($calamaresProcesses =~ /0/gm) {
					printLog("third boot out of OEM, no calamares detected, deleting boot flag", 'L2', '[DEBUG]');
					delete $configIniValues->{installation};
					writeConfigIniFile();
				}
			}
		} elsif (!$FAI && defined($configIniValues->{installation}->{FAI}) && ($configIniValues->{installation}->{FAI} eq 'first reboot after FAI')) {
			delete $configIniValues->{installation};

			writeConfigIniFile();
		}
		# just to be sure, always write the tomte_finished file
	}
}
